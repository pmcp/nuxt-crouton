# Unified Crouton Architecture - Design Brief

**Date**: 2026-01-20
**Status**: Proposal for Review
**Author**: Claude (Architecture Discussion)

---

## Executive Summary

This document proposes migrating nuxt-crouton **framework packages** from Nuxt Layers to Nuxt Modules with config-driven features. The goal is to simplify the user experience, eliminate build-order dependencies, and consolidate configuration.

**Critical Distinction**: This proposal affects only **framework packages** (`@fyit/crouton-*`). User-generated layers (created by the CLI) remain as traditional Nuxt layers.

---

## Key Concept: Two Types of Layers

Before diving into the architecture, it's essential to understand that "layers" in this codebase serve two different purposes:

### 1. Framework Layers (→ Convert to Modules)

These are the `@fyit/crouton-*` packages that provide framework capabilities:

```
@fyit/crouton-core      # Base utilities, types, composables
@fyit/crouton-auth      # Authentication (Better Auth)
@fyit/crouton-editor    # Rich text editor (TipTap)
@fyit/crouton-pages     # CMS pages
@fyit/crouton-bookings  # Booking system
```

**Characteristics:**
- Published to npm
- Consumed via `node_modules`
- Must be built before use
- Rarely modified by users

### 2. User/Generated Layers (→ Stay as Layers)

These are domain-specific layers created by the CLI or manually by users:

```
~/my-app/layers/
├── shop/
│   └── collections/
│       ├── products/
│       └── categories/
└── blog/
    └── collections/
        └── posts/
```

**Characteristics:**
- Generated by `crouton generate` CLI
- Live in user's project folder
- Fully editable by users
- Use Nuxt's layer auto-discovery

### How They Work Together

```
┌─────────────────────────────────────────────────────────────┐
│  @fyit/crouton (MODULE)                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌───────────────┐     │
│  │ crouton-core │  │ crouton-auth │  │ crouton-editor│     │
│  │   (always)   │  │ (if enabled) │  │  (if enabled) │     │
│  └──────────────┘  └──────────────┘  └───────────────┘     │
│  Provides: useCroutonCollection, CroutonForm, etc.          │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ installModule() at build time
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  User's nuxt.config.ts                                      │
│  modules: ['@fyit/crouton']      ← Framework module         │
│  extends: ['./layers/shop']      ← User-generated layers    │
└─────────────────────────────────────────────────────────────┘
                            │
               ┌────────────┘
               ▼
┌─────────────────────────────────────────────────────────────┐
│  ./layers/shop (USER LAYER - remains a layer)               │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ collections/products/                                   │ │
│  │   schema.ts              # Field definitions            │ │
│  │   composables/           # useProducts(), etc.          │ │
│  │   components/            # ProductForm.vue, etc.        │ │
│  │   server/api/            # CRUD endpoints               │ │
│  └────────────────────────────────────────────────────────┘ │
│  Generated by: crouton generate                             │
│  Owned by: User (can edit, customize)                       │
└─────────────────────────────────────────────────────────────┘
```

---

## Current Architecture

### How It Works Today

```
@fyit/crouton           # Unified entry point (exports getCroutonLayers helper)
@fyit/crouton-core      # Base utilities, types
@fyit/crouton-auth      # Authentication (Better Auth)
@fyit/crouton-admin     # Admin dashboard
@fyit/crouton-i18n      # Translations
@fyit/crouton-editor    # Rich text (TipTap)
@fyit/crouton-pages     # CMS pages
@fyit/crouton-bookings  # Booking system
... (more packages)
```

Each package is a **Nuxt Layer** that users add to their `extends` array.

### Current User Setup

```typescript
// nuxt.config.ts
import { getCroutonLayers } from '@fyit/crouton'

export default defineNuxtConfig({
  extends: [
    ...getCroutonLayers(),  // Returns ['@fyit/crouton-core', '@fyit/crouton-auth', ...]
    './layers/my-layer'
  ],
  modules: ['@fyit/crouton', '@nuxthub/core', '@nuxt/ui'],
  crouton: { /* some config */ }
})
```

Plus a separate config file:

```javascript
// crouton.config.js
export default {
  features: {
    editor: true,
    pages: true
  },
  collections: [
    { name: 'products', fieldsFile: './schemas/products.json' }
  ]
}
```

### Problems with Current Architecture

| Problem | Description |
|---------|-------------|
| **Build-order dependency** | `getCroutonLayers()` requires `@fyit/crouton` to be built. In CI, fresh checkouts fail because `dist/` doesn't exist yet. |
| **Config in multiple places** | Features defined in `crouton.config.js`, some settings in `nuxt.config.ts crouton:` block. |
| **Complex extends management** | Users must understand layers vs modules, manually manage the extends array. |
| **Unnecessary complexity** | Standalone package usage is rare; most users want the full suite. |

### CI Failure Details

```
Error: No "exports" main defined in @fyit/crouton/package.json
```

**Root cause**: `pnpm install` triggers `postinstall` scripts which run `nuxt prepare`. This loads `nuxt.config.ts` which imports `getCroutonLayers` from `@fyit/crouton`. But `@fyit/crouton` points to `./dist/module.mjs` which doesn't exist in fresh checkouts.

---

## Proposed Architecture

### Target User Experience

```typescript
// nuxt.config.ts - THE ONLY CONFIG FILE
export default defineNuxtConfig({
  // Framework module - handles all @fyit/crouton-* packages
  modules: ['@fyit/crouton'],

  // User-generated layers - still in extends (this is correct!)
  extends: [
    './layers/shop',    // Generated by CLI
    './layers/blog'     // Generated by CLI
  ],

  crouton: {
    // Feature toggles (which framework modules to enable)
    features: {
      editor: true,
      pages: true,
      bookings: true
    },

    // Auth configuration
    auth: {
      providers: ['credentials', 'google']
    },

    // Collection generation (currently in crouton.config.js)
    collections: [
      {
        name: 'products',
        layer: 'shop',
        schema: './schemas/products.json',
        seed: true
      }
    ],

    dialect: 'sqlite'
  }
})
```

**Key changes:**
- No `getCroutonLayers()` helper needed
- No `crouton.config.js` file
- Framework packages loaded via module, not extends
- User layers still use `extends` (this is intentional - they need auto-discovery)

### How It Works

1. User adds `'@fyit/crouton'` to modules array
2. Module reads `crouton.features` config
3. Module dynamically installs required feature modules using `installModule()`
4. Each feature module registers its components/composables via Nuxt Kit

```typescript
// packages/crouton/src/module.ts
import { defineNuxtModule, installModule } from '@nuxt/kit'

export default defineNuxtModule<CroutonOptions>({
  meta: { name: '@fyit/crouton', configKey: 'crouton' },

  defaults: {
    features: {
      auth: true,
      admin: true,
      i18n: true,
      editor: false,
      pages: false,
      bookings: false
    }
  },

  async setup(options, nuxt) {
    // Always install core
    await installModule('@fyit/crouton-core')

    // Conditionally install features
    if (options.features?.auth !== false) {
      await installModule('@fyit/crouton-auth', options.auth)
    }
    if (options.features?.editor) {
      await installModule('@fyit/crouton-editor')
    }
    // ... etc
  }
})
```

### Key Change: Framework Layers → Modules

**Current**: Framework packages are Nuxt Layers (added via `extends`)
**Proposed**: Framework packages are Nuxt Modules (installed via `installModule()`)

| Package Type | Current | Proposed |
|--------------|---------|----------|
| `@fyit/crouton-core` | Layer (extends) | Module (installModule) |
| `@fyit/crouton-auth` | Layer (extends) | Module (installModule) |
| `@fyit/crouton-editor` | Layer (extends) | Module (installModule) |
| `./layers/my-domain` | Layer (extends) | **Layer (extends)** - unchanged |

**User-generated layers remain as layers** because:
1. They're local files, not npm packages (no build-order issues)
2. They need layer auto-discovery for components/composables
3. Users edit them directly
4. The CLI generates them as layers

Modules can:
- Register components: `addComponent({ name, filePath })`
- Register composables: `addImports({ name, from })`
- Add server handlers: `addServerHandler({ route, handler })`
- Be dynamically installed: `await installModule('@fyit/crouton-editor')`

This eliminates `getCroutonLayers()` helper while preserving user layer functionality.

---

## Migration Plan

### Phase 0: Immediate CI Fix

Inline the layers in `apps/crouton-test/nuxt.config.ts` to unblock CI while we work on the larger refactor.

### Phase 1: Convert Layers to Modules

For each `@fyit/crouton-*` package:
1. Create `src/module.ts` using `defineNuxtModule`
2. Move runtime code to `src/runtime/` directory
3. Register components/composables via Nuxt Kit instead of layer auto-discovery
4. Export as module instead of layer

**Example conversion**:

```typescript
// packages/crouton-editor/src/module.ts
import { defineNuxtModule, addComponent, addImports, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  meta: { name: '@fyit/crouton-editor', configKey: 'croutonEditor' },

  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // Register components (was auto-discovered as layer)
    addComponent({
      name: 'CroutonEditor',
      filePath: resolver.resolve('./runtime/components/CroutonEditor.vue')
    })
    addComponent({
      name: 'CroutonEditorSimple',
      filePath: resolver.resolve('./runtime/components/CroutonEditorSimple.vue')
    })

    // Register composables (was auto-discovered as layer)
    addImports({
      name: 'useEditor',
      from: resolver.resolve('./runtime/composables/useEditor')
    })
  }
})
```

**Priority order** (based on dependencies):
1. crouton-core (no deps)
2. crouton-auth (deps: core)
3. crouton-admin (deps: core, auth)
4. crouton-i18n (deps: core)
5. crouton-editor (deps: core)
6. crouton-pages (deps: core, editor)
7. Others...

### Phase 2: Unified Entry Module

Rewrite `@fyit/crouton` to use `installModule()` for dynamic feature loading.

### Phase 3: Unified Config

1. Update CLI to read from `nuxt.config.ts` instead of `crouton.config.js`
2. Add deprecation warning for `crouton.config.js`
3. Support both during transition period

### Phase 4: Cleanup

1. Remove `getCroutonLayers()` helper
2. Remove layer-specific nuxt.config.ts from packages
3. Update all documentation
4. Create migration guide

---

## Trade-offs

### What We Gain

| Benefit | Description |
|---------|-------------|
| Simpler user setup | One module for framework, user layers still work naturally |
| No build-order issues | Modules don't need `getCroutonLayers()` import at config load time |
| Single source of truth | All framework config in `crouton:` block |
| Better DX | Clear separation: modules = framework, layers = user domain |
| Studio compatibility | Validates hybrid module + layer pattern |

### What We Lose

| Loss | Mitigation |
|------|------------|
| Framework layer overrides | Document alternative patterns (aliasing, config options) |
| Layer auto-discovery for framework | Explicit registration via Nuxt Kit is more maintainable |
| Existing user configs | Provide migration guide; user layers unchanged |

### What Stays the Same

| Aspect | Notes |
|--------|-------|
| User-generated layers | `./layers/my-domain` still uses extends, still auto-discovers |
| CLI workflow | `crouton generate` still creates layers |
| Layer editing | Users still edit generated components directly |
| Layer merging | Multiple user layers still merge correctly |

---

## Open Questions for Review

### 1. installModule() Reliability (HIGH RISK)

**Question**: Has `installModule()` been tested with complex modules that have components, composables, and server utils?

**Concerns**:
- **Timing**: When parent module calls `installModule('@fyit/crouton-editor')`, does child's `setup()` run before or after parent completes? This affects plugin order.
- **Config merging**: If child module adds to `nuxt.config.ts` (e.g., `vite.optimizeDeps`), does that work when dynamically installed?
- **Dependency chains**: If module A installs module B which installs module C, are all hooks fired correctly?

**Mitigation**: Spike with `crouton-editor` before full migration.

**Risk Level**: HIGH - Needs empirical validation

---

### 2. Bundle Size / Tree-shaking (MEDIUM RISK)

**Question**: Will unused features get tree-shaken when conditionally loaded?

**Analysis**:
```typescript
if (options.features?.editor) {
  await installModule('@fyit/crouton-editor')
}
```

At build time with `editor: false`, `installModule()` never runs. The code shouldn't end up in client bundle. However, the package is still in `node_modules`.

**Trade-off Options**:
| Approach | Pros | Cons |
|----------|------|------|
| All as `dependencies` | Simple setup, always available | Larger `pnpm install` |
| As `peerDependencies` | Minimal install size | Users must install features explicitly |

**Risk Level**: MEDIUM - Acceptable, measure in spike

---

### 3. Type Generation (LOW RISK)

**Question**: Will TypeScript types work correctly with dynamic module installation?

**Analysis**: When a module calls `addComponent()` or `addImports()`, Nuxt Kit generates types into `.nuxt/components.d.ts` and `.nuxt/imports.d.ts`. The mechanism is the same whether module is in `modules:[]` directly or via `installModule()`.

**Potential Edge Case**: If types depend on build order (module A's types reference module B's exports), there could be issues. Crouton packages are mostly independent, so this is unlikely.

**Risk Level**: LOW - Should work, confirm in spike

---

### 4. Server Utils Registration (HIGH RISK)

**Question**: How do server utils get registered when using modules instead of layers?

**The Problem**: Layers automatically merge server directories:
```
layers/crouton-auth/server/utils/auth.ts  → useAuth() in server
layers/crouton-auth/server/api/login.post.ts → auto-registered route
```

Modules require explicit registration:
```typescript
// Must call addServerHandler() for each route
addServerHandler({
  route: '/api/auth/login',
  method: 'post',
  handler: resolver.resolve('./runtime/server/api/auth/login.post')
})
```

**If package has 15 API routes**: That's 15 `addServerHandler()` calls. Verbose and error-prone.

**Possible Solutions**:
1. Use `addServerScanDir()` if available in Nuxt Kit
2. Write helper that glob-scans and registers all routes
3. Accept verbosity as "explicit is better than implicit"

**Risk Level**: HIGH - Needs solution before migration

---

### 5. Hot Reload (LOW RISK)

**Question**: Does HMR work correctly with dynamically installed modules?

**Analysis**: HMR is handled at Vite level, not module installation level. Once a component is registered (regardless of how), HMR should work.

**Edge Case**: Changing `features.editor: false → true` in config requires full restart. This is expected - config changes always require restart.

**Risk Level**: LOW - Should work

---

### 6. User Component Overrides (NEW)

**Question**: How do users override crouton components with the module approach?

**Current (Layers)**:
```typescript
extends: ['@fyit/crouton-editor', './layers/my-overrides']
// my-overrides/components/CroutonEditor.vue takes precedence
```

**With Modules**: This pattern breaks. Options:
1. Don't enable the feature, provide own implementation
2. Use Nuxt's component aliasing (more complex)
3. Provide explicit override mechanism in module config

**Risk Level**: MEDIUM - May affect power users

---

### Risk Assessment Summary

| Question | Risk | Spike Required? |
|----------|------|-----------------|
| #1 installModule() reliability | HIGH | Yes |
| #2 Bundle size | MEDIUM | Yes (measure) |
| #3 Type generation | LOW | Yes (confirm) |
| #4 Server utils registration | HIGH | Yes |
| #5 Hot reload | LOW | No |
| #6 Component overrides | MEDIUM | Document solution |

---

## Files Affected

### High Impact
- `packages/crouton/src/module.ts` - Complete rewrite
- `packages/crouton-*/` - Each needs module.ts conversion
- `packages/crouton-cli/lib/` - Config loading changes

### Medium Impact
- `apps/*/nuxt.config.ts` - All apps need config migration
- `apps/docs/content/` - Documentation updates

### Low Impact
- CI workflows - May simplify after migration

---

## Relationship to Crouton Designer

This architecture supports the [Crouton Designer v2](/docs/plans/schema-designer-v2.md), an AI-guided app builder deployed as a standalone Cloudflare app. The designer dogfoods the crouton framework — its own state (Projects, Collections, Fields) is stored as Crouton collections.

---

## Spike Plan

Before committing to full migration, validate with a focused spike:

### Spike Scope: Convert crouton-editor

**Why editor?** Medium complexity, no critical dependencies, optional feature.

### Spike Checklist

- [ ] Component auto-imports work (`<CroutonEditor />`)
- [ ] Composable auto-imports work (`useEditor()`)
- [ ] TypeScript types generate correctly in `.nuxt/`
- [ ] HMR works when editing component source
- [ ] Production build tree-shakes when `editor: false`
- [ ] `installModule()` works from parent module
- [ ] Server utils registered correctly (if any)
- [ ] No runtime errors in dev or production

### Spike Duration

Estimate: 1-2 days to convert and validate

### Go/No-Go Criteria

**Proceed if**:
- All checklist items pass
- No unexpected Nuxt Kit limitations discovered
- Server registration has acceptable solution

**Pause if**:
- `installModule()` has timing/ordering issues
- Type generation fails
- Server utils require excessive boilerplate

---

## Recommendation

Proceed with this architecture change, but **validate with spike first**.

The benefits (simpler UX, no build-order issues, unified config) outweigh the migration cost. The current architecture's CI failures are a symptom of fundamental complexity that this refactor addresses.

**Execution order**:
1. **Phase 0**: Inline layers in test apps (unblock CI immediately)
2. **Spike**: Convert crouton-editor, validate checklist
3. **Decision point**: Go/no-go based on spike results
4. **If go**: Proceed with Phases 1-4

---

## References

- [Nuxt Modules Documentation](https://nuxt.com/docs/guide/going-further/modules)
- [Nuxt Kit API](https://nuxt.com/docs/api/kit)
- [installModule()](https://nuxt.com/docs/api/kit/modules#installmodule)
- Current CI failure: Run #21161277882