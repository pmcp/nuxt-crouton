/**
 * Get Public Pages for Team
 *
 * Returns published pages for navigation and public display.
 * - Unauthenticated: only public pages
 * - Authenticated team members: public + members pages
 *
 * GET /api/teams/[id]/pages
 *
 * Query params:
 * - navigation=true: Only return pages with showInNavigation=true
 * - visibility: Filter by visibility (public, members, hidden)
 */
import { eq, and, or, asc, inArray } from 'drizzle-orm'

export default defineEventHandler(async (event) => {
  const teamParam = getRouterParam(event, 'id')

  if (!teamParam) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Team ID or slug is required'
    })
  }

  const query = getQuery(event)
  const navigationOnly = query.navigation === 'true'
  const visibilityFilter = query.visibility as string | undefined

  try {
    // Import schema - using dynamic import since layer structure
    // In consuming apps, this would be auto-imported
    const database = db

    // First, resolve team ID from slug if needed
    const authSchema = await import('@fyit/crouton-auth/server/database/schema/auth')

    const team = await database
      .select({ id: authSchema.organization.id })
      .from(authSchema.organization)
      .where(
        or(
          eq(authSchema.organization.id, teamParam),
          eq(authSchema.organization.slug, teamParam)
        )
      )
      .limit(1)
      .then((rows: Array<{ id: string }>) => rows[0])

    if (!team) {
      throw createError({
        statusCode: 404,
        statusMessage: 'Team not found'
      })
    }

    // Check if user is authenticated and a team member
    let isMember = false
    try {
      const { getServerSession } = await import('@fyit/crouton-auth/server/utils/useServerAuth')
      const session = await getServerSession(event)

      if (session?.user) {
        // Check team membership
        const membership = await database
          .select({ id: authSchema.member.id })
          .from(authSchema.member)
          .where(
            and(
              eq(authSchema.member.userId, session.user.id),
              eq(authSchema.member.organizationId, team.id)
            )
          )
          .limit(1)
          .then((rows: any[]) => rows[0])

        isMember = !!membership
      }
    } catch {
      // Auth not available or error - continue as unauthenticated
    }

    // Try to get pages from the pagesPages table
    // This table is generated by crouton CLI from crouton.manifest.ts
    // The table might not exist yet if collection hasn't been generated
    try {
      // Dynamic import of generated schema (uses ~~ to resolve from app root)
      const pagesSchema = await import('~~/layers/pages/collections/pages/server/database/schema')

      // Build query conditions
      const conditions = [
        eq(pagesSchema.pagesPages.teamId, team.id),
        eq(pagesSchema.pagesPages.status, 'published')
      ]

      // Add navigation filter
      if (navigationOnly) {
        conditions.push(eq(pagesSchema.pagesPages.showInNavigation, true))
      }

      // Add visibility filter based on auth status
      if (visibilityFilter) {
        conditions.push(eq(pagesSchema.pagesPages.visibility, visibilityFilter))
      } else if (isMember) {
        // Authenticated members see public + members pages
        conditions.push(inArray(pagesSchema.pagesPages.visibility, ['public', 'members']))
      } else {
        // Default: only show public pages
        conditions.push(eq(pagesSchema.pagesPages.visibility, 'public'))
      }

      const pages = await database
        .select({
          id: pagesSchema.pagesPages.id,
          title: pagesSchema.pagesPages.title,
          slug: pagesSchema.pagesPages.slug,
          pageType: pagesSchema.pagesPages.pageType,
          status: pagesSchema.pagesPages.status,
          visibility: pagesSchema.pagesPages.visibility,
          showInNavigation: pagesSchema.pagesPages.showInNavigation,
          parentId: pagesSchema.pagesPages.parentId,
          order: pagesSchema.pagesPages.order,
          depth: pagesSchema.pagesPages.depth,
          path: pagesSchema.pagesPages.path
        })
        .from(pagesSchema.pagesPages)
        .where(and(...conditions))
        .orderBy(
          asc(pagesSchema.pagesPages.depth),
          asc(pagesSchema.pagesPages.order)
        )

      return {
        data: pages,
        meta: {
          teamId: team.id,
          total: pages.length
        }
      }
    } catch {
      // pagesPages table doesn't exist yet
      // Return empty array (collection needs to be generated)
      return {
        data: [],
        meta: {
          teamId: team.id,
          total: 0,
          message: 'Pages collection not generated yet. Run: pnpm crouton generate'
        }
      }
    }
  } catch (error: any) {
    if (error.statusCode) {
      throw error
    }
    console.error('[crouton-pages] Error fetching pages:', error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Failed to fetch pages'
    })
  }
})
