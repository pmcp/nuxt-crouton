import type { CollectionWithFields } from './useCollectionEditor'

export interface ValidationIssue {
  type: 'error' | 'warning'
  collectionId?: string
  fieldId?: string
  message: string
  code: string
}

const RESERVED_NAMES = new Set([
  'id', 'teamId', 'owner', 'createdAt', 'updatedAt', 'createdBy', 'updatedBy',
  'order', 'optimisticId', 'optimisticAction'
])

const RESERVED_COLLECTION_NAMES = new Set([
  'api', 'server', 'app', 'pages', 'components', 'composables', 'layouts',
  'middleware', 'plugins', 'assets', 'public', 'node_modules'
])

export function useSchemaValidation(collections: Ref<CollectionWithFields[]>) {
  const { t } = useT()

  const issues = computed<ValidationIssue[]>(() => {
    const result: ValidationIssue[] = []
    const collectionNames = new Map<string, string>() // name â†’ id

    for (const col of collections.value) {
      // Empty collection
      if (col.fields.length === 0) {
        result.push({
          type: 'warning',
          collectionId: col.id,
          message: t('designer.validation.collectionNoFields', { params: { name: col.name } }),
          code: 'empty-collection'
        })
      }

      // Duplicate collection names
      const lowerName = col.name.toLowerCase()
      if (collectionNames.has(lowerName)) {
        result.push({
          type: 'error',
          collectionId: col.id,
          message: t('designer.validation.duplicateCollection', { params: { name: col.name } }),
          code: 'duplicate-collection-name'
        })
      }
      collectionNames.set(lowerName, col.id)

      // Reserved collection names
      if (RESERVED_COLLECTION_NAMES.has(lowerName)) {
        result.push({
          type: 'error',
          collectionId: col.id,
          message: t('designer.validation.reservedName', { params: { name: col.name } }),
          code: 'reserved-collection-name'
        })
      }

      // Field-level validation
      const fieldNames = new Set<string>()

      for (const field of col.fields) {
        // Duplicate field names within collection
        const lowerFieldName = field.name.toLowerCase()
        if (fieldNames.has(lowerFieldName)) {
          result.push({
            type: 'error',
            collectionId: col.id,
            fieldId: field.id,
            message: t('designer.validation.duplicateField', { params: { field: field.name, collection: col.name } }),
            code: 'duplicate-field-name'
          })
        }
        fieldNames.add(lowerFieldName)

        // Reserved field names
        if (RESERVED_NAMES.has(field.name)) {
          result.push({
            type: 'warning',
            collectionId: col.id,
            fieldId: field.id,
            message: t('designer.validation.autoGenerated', { params: { field: field.name } }),
            code: 'reserved-field-name'
          })
        }

        // Missing reference target
        if (field.type === 'reference' && !field.refTarget) {
          result.push({
            type: 'error',
            collectionId: col.id,
            fieldId: field.id,
            message: t('designer.validation.refNoTarget', { params: { field: field.name } }),
            code: 'missing-ref-target'
          })
        }

        // Reference target doesn't exist
        if (field.type === 'reference' && field.refTarget) {
          const targetExists = collections.value.some(
            c => c.name === field.refTarget || c.id === field.refTarget
          )
          if (!targetExists) {
            result.push({
              type: 'error',
              collectionId: col.id,
              fieldId: field.id,
              message: t('designer.validation.refTargetMissing', { params: { target: field.refTarget } }),
              code: 'invalid-ref-target'
            })
          }
        }

        // DependsOn validation
        const meta = field.meta || {}
        if (meta.dependsOn) {
          const parentExists = col.fields.some(f => f.name === meta.dependsOn && f.id !== field.id)
          if (!parentExists) {
            result.push({
              type: 'error',
              collectionId: col.id,
              fieldId: field.id,
              message: t('designer.validation.dependsOnMissing', { params: { field: meta.dependsOn, collection: col.name } }),
              code: 'invalid-depends-on'
            })
          }
        }

        if (meta.dependsOnCollection) {
          const targetCol = collections.value.find(c => c.name === meta.dependsOnCollection)
          if (!targetCol) {
            result.push({
              type: 'error',
              collectionId: col.id,
              fieldId: field.id,
              message: t('designer.validation.dependsOnCollectionMissing', { params: { collection: meta.dependsOnCollection } }),
              code: 'invalid-depends-on-collection'
            })
          }
          else if (meta.dependsOnField) {
            const targetField = targetCol.fields.some(f => f.name === meta.dependsOnField)
            if (!targetField) {
              result.push({
                type: 'error',
                collectionId: col.id,
                fieldId: field.id,
                message: t('designer.validation.dependsOnFieldMissing', { params: { field: meta.dependsOnField, collection: meta.dependsOnCollection } }),
                code: 'invalid-depends-on-field'
              })
            }
          }
        }
      }
    }

    // Circular reference detection
    const circularRefs = detectCircularReferences(collections.value, t)
    result.push(...circularRefs)

    return result
  })

  const errors = computed(() => issues.value.filter(i => i.type === 'error'))
  const warnings = computed(() => issues.value.filter(i => i.type === 'warning'))
  const hasErrors = computed(() => errors.value.length > 0)

  function getCollectionIssues(collectionId: string) {
    return issues.value.filter(i => i.collectionId === collectionId)
  }

  function getFieldIssues(fieldId: string) {
    return issues.value.filter(i => i.fieldId === fieldId)
  }

  return {
    issues,
    errors,
    warnings,
    hasErrors,
    getCollectionIssues,
    getFieldIssues
  }
}

function detectCircularReferences(collections: CollectionWithFields[], t: (key: string, options?: any) => string): ValidationIssue[] {
  const issues: ValidationIssue[] = []
  const graph = new Map<string, Set<string>>()

  // Build adjacency list from reference fields
  for (const col of collections) {
    const targets = new Set<string>()
    for (const field of col.fields) {
      if (field.type === 'reference' && field.refTarget) {
        targets.add(field.refTarget)
      }
    }
    graph.set(col.name, targets)
  }

  // DFS to detect cycles
  const visited = new Set<string>()
  const inStack = new Set<string>()

  function dfs(name: string, path: string[]): boolean {
    if (inStack.has(name)) {
      const cycleStart = path.indexOf(name)
      const cycle = path.slice(cycleStart).concat(name)
      issues.push({
        type: 'warning',
        message: t('designer.validation.circularReference', { params: { cycle: cycle.join(' \u2192 ') } }),
        code: 'circular-reference'
      })
      return true
    }
    if (visited.has(name)) return false

    visited.add(name)
    inStack.add(name)

    const targets = graph.get(name) || new Set()
    for (const target of targets) {
      dfs(target, [...path, name])
    }

    inStack.delete(name)
    return false
  }

  for (const col of collections) {
    if (!visited.has(col.name)) {
      dfs(col.name, [])
    }
  }

  return issues
}
