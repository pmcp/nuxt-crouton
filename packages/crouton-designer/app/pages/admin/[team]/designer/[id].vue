<script setup lang="ts">
import type { StepperItem } from '@nuxt/ui'
import type { ProjectConfig, DesignerProject, SeedDataMap } from '../../../../types/schema'
import type { CollectionWithFields } from '../../../../composables/useCollectionEditor'

definePageMeta({
  middleware: ['auth'],
  layout: 'admin'
})

const route = useRoute()
const router = useRouter()
const teamSlug = computed(() => route.params.team as string)
const projectId = computed(() => route.params.id as string)
const isNewProject = computed(() => projectId.value === 'new')

const { buildApiUrl } = useTeamContext()
const { buildSystemPrompt: buildIntakePrompt } = useIntakePrompt()
const { buildSystemPrompt: buildCollectionPrompt } = useCollectionDesignPrompt()
const { buildSystemPrompt: buildSeedDataPrompt } = useSeedDataPrompt()
const { buildSystemPrompt: buildReviewPrompt } = useReviewPrompt()
const toast = useToast()
const { t } = useT()

// ------- Project state -------
const projectConfig = ref<ProjectConfig>({
  name: '',
  description: '',
  appType: undefined,
  multiTenant: undefined,
  authType: undefined,
  languages: [],
  defaultLocale: 'en',
  packages: []
})

const currentPhase = ref<string>('1')
const chatCollapsed = ref(false)
const projectRecord = ref<DesignerProject | null>(null)

// ------- Seed data (Phase 3) -------
const seedData = ref<SeedDataMap>({})
const seedDataCollections = ref<CollectionWithFields[]>([])
const showCascadeWarning = ref(false)

// ------- Backward navigation -------
const showBackwardWarning = ref(false)
const pendingPhaseChange = ref<string | null>(null)

// ------- Collection editor (Phase 2) -------
const collectionEditorRef = ref<{ editor: ReturnType<typeof useCollectionEditor> } | null>(null)

// ------- Load project from DB -------
const { data: projectData, status: projectStatus } = await useFetch<DesignerProject[]>(
  () => buildApiUrl(`/designer-projects?ids=${projectId.value}`),
  {
    immediate: !isNewProject.value,
    default: () => []
  }
)

// Initialize from loaded project
watch(projectData, (projects) => {
  if (projects && projects.length > 0) {
    const proj = projects[0]!
    projectRecord.value = proj
    if (proj.config && typeof proj.config === 'object') {
      projectConfig.value = { ...projectConfig.value, ...proj.config as ProjectConfig }
    }
    if (proj.currentPhase) {
      currentPhase.value = proj.currentPhase
    }
    if (proj.seedData && typeof proj.seedData === 'object') {
      seedData.value = proj.seedData as SeedDataMap
    }
  }
}, { immediate: true })

// ------- Create new project -------
async function ensureProject(): Promise<string> {
  if (projectRecord.value?.id) return projectRecord.value.id

  const result = await $fetch<DesignerProject>(buildApiUrl('/designer-projects'), {
    method: 'POST',
    body: {
      name: projectConfig.value.name || 'Untitled Project',
      currentPhase: '1',
      config: projectConfig.value,
      messages: []
    }
  })
  projectRecord.value = result
  if (isNewProject.value) {
    router.replace(`/admin/${teamSlug.value}/designer/${result.id}`)
  }
  return result.id
}

// ------- Persist config to DB -------
let saveTimer: ReturnType<typeof setTimeout> | null = null

async function saveConfig() {
  const id = await ensureProject()
  await $fetch(buildApiUrl(`/designer-projects/${id}`), {
    method: 'PATCH',
    body: {
      config: projectConfig.value,
      name: projectConfig.value.name || 'Untitled Project'
    }
  })
}

function debouncedSave() {
  if (saveTimer) clearTimeout(saveTimer)
  saveTimer = setTimeout(saveConfig, 800)
}

// ------- Persist seed data to DB -------
let seedSaveTimer: ReturnType<typeof setTimeout> | null = null

async function saveSeedData() {
  if (!projectRecord.value?.id) return
  await $fetch(buildApiUrl(`/designer-projects/${projectRecord.value.id}`), {
    method: 'PATCH',
    body: { seedData: seedData.value }
  })
}

function debouncedSaveSeedData() {
  if (seedSaveTimer) clearTimeout(seedSaveTimer)
  seedSaveTimer = setTimeout(saveSeedData, 800)
}

// ------- Config updates (from summary card or AI tool) -------
function updateConfig(partial: Partial<ProjectConfig>) {
  projectConfig.value = { ...projectConfig.value, ...partial }
  debouncedSave()
}

// ------- Auto-generated field filter -------
const AUTO_GENERATED_FIELDS = new Set(['id', 'teamId', 'createdAt', 'updatedAt', 'createdBy', 'updatedBy'])

function filterAutoGeneratedFields(fields: Array<{ name: string; [key: string]: any }>) {
  return fields.filter(f => !AUTO_GENERATED_FIELDS.has(f.name))
}

// ------- AI Chat -------
const systemPrompt = computed(() => {
  if (currentPhase.value === '5') {
    // Review phase — use seed data collections (snapshot from Phase 3) or fall back to empty
    return buildReviewPrompt(projectConfig.value, seedDataCollections.value)
  }
  if (currentPhase.value === '3') {
    return buildSeedDataPrompt(projectConfig.value, seedDataCollections.value, seedData.value)
  }
  if (currentPhase.value === '2') {
    const editor = collectionEditorRef.value?.editor
    const collections = toValue(editor?.collectionsWithFields) || []
    return buildCollectionPrompt(projectConfig.value, collections)
  }
  return buildIntakePrompt(projectConfig.value)
})

const { messages, input, isLoading, status, error, append, toolCalls, reload } = useChat({
  api: '/api/ai/designer-chat',
  maxSteps: 5,
  body: computed(() => ({
    system: systemPrompt.value,
    phase: currentPhase.value
  })),
  onToolCall: async ({ toolCall }) => {
    try {
    // Phase 1 tools
    if (toolCall.toolName === 'set_app_config') {
      const args = toolCall.args as Partial<ProjectConfig>
      updateConfig(args)
      return { success: true, config: args }
    }

    // Phase 3 tools
    if (toolCall.toolName === 'set_seed_data') {
      const args = toolCall.args as { collectionName: string; entries: Array<Record<string, any>> }
      seedData.value = { ...seedData.value, [args.collectionName]: args.entries }
      debouncedSaveSeedData()
      return { success: true, collectionName: args.collectionName, count: args.entries.length }
    }

    // Phase 2 tools
    const editor = collectionEditorRef.value?.editor
    if (!editor) return { success: false, error: 'Editor not ready' }

    const args = toolCall.args as Record<string, any>

    if (toolCall.toolName === 'create_collection') {
      const collection = await editor.createCollection({
        name: args.name,
        description: args.description,
        display: args.display
      })
      // Create initial fields if provided (filter out auto-generated fields)
      const fields = args.fields?.length ? filterAutoGeneratedFields(args.fields) : []
      for (const field of fields) {
        await editor.addField({
          collectionId: collection.id,
          name: field.name,
          type: field.type,
          meta: field.meta,
          refTarget: field.refTarget
        })
      }
      return { success: true, collectionId: collection.id, name: args.name }
    }

    if (toolCall.toolName === 'update_collection') {
      await editor.updateCollection(args.collectionId, {
        name: args.name,
        description: args.description,
        display: args.display
      })
      return { success: true }
    }

    if (toolCall.toolName === 'delete_collection') {
      await editor.deleteCollection(args.collectionId)
      return { success: true }
    }

    if (toolCall.toolName === 'add_field') {
      // Silently skip auto-generated fields
      if (AUTO_GENERATED_FIELDS.has(args.name)) {
        return { success: true, skipped: true, reason: `${args.name} is auto-generated` }
      }
      const field = await editor.addField({
        collectionId: args.collectionId,
        name: args.name,
        type: args.type,
        meta: args.meta,
        refTarget: args.refTarget
      })
      return { success: true, fieldId: field.id }
    }

    if (toolCall.toolName === 'update_field') {
      await editor.updateField(args.fieldId, {
        name: args.name,
        type: args.type,
        meta: args.meta,
        refTarget: args.refTarget
      })
      return { success: true }
    }

    if (toolCall.toolName === 'delete_field') {
      await editor.deleteField(args.fieldId)
      return { success: true }
    }

    if (toolCall.toolName === 'reorder_fields') {
      await editor.reorderFields(args.collectionId, args.fieldIds)
      return { success: true }
    }

    return { success: false, error: `Unknown tool: ${toolCall.toolName}` }
    } catch (err) {
      console.error(`Tool call failed (${toolCall.toolName}):`, err)
      const message = (err as Error).message
      const suggestion = toolCall.toolName === 'create_collection'
        ? 'Check that the collection name is unique and not empty.'
        : toolCall.toolName.startsWith('update_') || toolCall.toolName.startsWith('delete_')
          ? 'The target may have been deleted. Try listing existing items first.'
          : 'Try the operation again or use a different approach.'
      return { success: false, error: message, toolName: toolCall.toolName, suggestion }
    }
  },
  onError: (err) => {
    console.error('Chat error:', err)
    toast.add({
      title: t('designer.ai.errorTitle'),
      description: t('designer.ai.errorMessage'),
      color: 'error'
    })
  }
})

function handleChatSend(text: string) {
  append({
    id: crypto.randomUUID(),
    role: 'user',
    content: text
  })
}

function handleChatRetry() {
  reload()
}

// ------- Chat message persistence (flat array) -------
async function persistPhase(phase: string) {
  if (!projectRecord.value?.id) return
  await $fetch(buildApiUrl(`/designer-projects/${projectRecord.value.id}`), {
    method: 'PATCH',
    body: { currentPhase: phase }
  })
}

let messageSaveTimer: ReturnType<typeof setTimeout> | null = null

async function saveMessages() {
  if (!projectRecord.value?.id || messages.value.length === 0) return
  const flat = messages.value.map(m => ({
    id: m.id,
    role: m.role,
    content: m.content
  }))
  await $fetch(buildApiUrl(`/designer-projects/${projectRecord.value.id}`), {
    method: 'PATCH',
    body: { messages: flat }
  })
}

function debouncedSaveMessages() {
  if (messageSaveTimer) clearTimeout(messageSaveTimer)
  messageSaveTimer = setTimeout(saveMessages, 1200)
}

// Auto-save messages when they change
watch(() => messages.value.length, () => {
  debouncedSaveMessages()
})

// Restore chat for loaded project (flat array)
if (projectRecord.value?.messages) {
  const stored = projectRecord.value.messages
  // Support both legacy per-phase format and new flat array
  if (Array.isArray(stored)) {
    for (const msg of stored) {
      messages.value.push(msg)
    }
  } else if (typeof stored === 'object') {
    // Legacy: merge all phase messages in order
    for (const phase of ['1', '2', '3', '5']) {
      const phaseMessages = (stored as Record<string, any>)[phase]
      if (Array.isArray(phaseMessages)) {
        for (const msg of phaseMessages) {
          messages.value.push(msg)
        }
      }
    }
  }
}

// ------- Phase navigation handler -------
function insertPhaseMarker(phase: string) {
  const phaseLabels: Record<string, string> = {
    '1': t('designer.phases.intake'),
    '2': t('designer.phases.collections'),
    '3': t('designer.phases.seedData'),
    '5': t('designer.phases.review')
  }
  messages.value.push({
    id: crypto.randomUUID(),
    role: 'system',
    content: `--- ${phaseLabels[phase] || `Phase ${phase}`} ---`
  } as any)
}

async function handlePhaseChange(val: string | number | undefined) {
  const newPhase = String(val)
  const current = currentPhase.value
  if (newPhase === current) return

  // Going to Phase 1 from any later phase: warn about config changes
  if (newPhase === '1' && current !== '1') {
    showBackwardWarning.value = true
    pendingPhaseChange.value = newPhase
    return
  }

  // Going back to Phase 2 from Phase 3+: warn about cascade delete of seed data
  if (newPhase === '2' && (current === '3' || current === '5')) {
    showCascadeWarning.value = true
    pendingPhaseChange.value = newPhase
    return
  }

  // Any other navigation
  insertPhaseMarker(newPhase)
  currentPhase.value = newPhase
  await persistPhase(newPhase)
}

function confirmBackward() {
  if (pendingPhaseChange.value) {
    insertPhaseMarker(pendingPhaseChange.value)
    currentPhase.value = pendingPhaseChange.value
    persistPhase(pendingPhaseChange.value)
  }
  showBackwardWarning.value = false
  pendingPhaseChange.value = null
}

function cancelBackward() {
  showBackwardWarning.value = false
  pendingPhaseChange.value = null
}

async function confirmCascadeDelete() {
  seedData.value = {}
  if (projectRecord.value?.id) {
    await $fetch(buildApiUrl(`/designer-projects/${projectRecord.value.id}`), {
      method: 'PATCH',
      body: { seedData: {} }
    })
  }
  if (pendingPhaseChange.value) {
    insertPhaseMarker(pendingPhaseChange.value)
    currentPhase.value = pendingPhaseChange.value
    persistPhase(pendingPhaseChange.value)
  }
  showCascadeWarning.value = false
  pendingPhaseChange.value = null
}

function cancelCascadeDelete() {
  showCascadeWarning.value = false
  pendingPhaseChange.value = null
}

// ------- Phase navigation -------
const phases = computed<StepperItem[]>(() => [
  {
    slot: 'intake' as const,
    title: t('designer.phases.intake'),
    description: t('designer.phases.intakeDescription'),
    icon: 'i-lucide-message-circle',
    value: '1'
  },
  {
    slot: 'collections' as const,
    title: t('designer.phases.collections'),
    description: t('designer.phases.collectionsDescription'),
    icon: 'i-lucide-database',
    value: '2'
  },
  {
    slot: 'seed-data' as const,
    title: t('designer.phases.seedData'),
    description: t('designer.phases.seedDataDescription'),
    icon: 'i-lucide-table',
    value: '3'
  },
  {
    slot: 'review' as const,
    title: t('designer.phases.review'),
    description: t('designer.phases.reviewDescription'),
    icon: 'i-lucide-rocket',
    value: '5'
  }
])

const canContinue = computed(() => !!(projectConfig.value.name && projectConfig.value.appType))

async function continueToCollections() {
  const id = await ensureProject()
  await $fetch(buildApiUrl(`/designer-projects/${id}`), {
    method: 'PATCH',
    body: {
      currentPhase: '2',
      config: projectConfig.value
    }
  })
  insertPhaseMarker('2')
  currentPhase.value = '2'
  // Auto-generate initial proposal after editor loads
  triggerInitialProposal()
}

// --- Auto-generate initial proposal on Phase 2 entry ---
const proposalTriggered = ref(false)

function triggerInitialProposal() {
  // Wait for editor to be ready, then send automatic AI message
  const stop = watch(
    () => collectionEditorRef.value?.editor,
    (editor) => {
      if (!editor || proposalTriggered.value) return
      // Only propose if no collections exist yet
      nextTick(async () => {
        await editor.fetchAll()
        if (toValue(editor.collections).length === 0 && !proposalTriggered.value) {
          proposalTriggered.value = true
          append({
            id: crypto.randomUUID(),
            role: 'user',
            content: `Based on the app configuration (${projectConfig.value.name} — ${projectConfig.value.appType}${projectConfig.value.description ? ': ' + projectConfig.value.description : ''}), propose an initial set of collections with fields. Be opinionated and create a complete, well-structured data model.`
          })
        }
        stop()
      })
    },
    { immediate: true }
  )
}

// Also trigger when loading an existing project that's in Phase 2
watch(currentPhase, (phase) => {
  if (phase === '2' && !proposalTriggered.value) {
    // Check if collections already exist — if so, don't propose
    const checkEditor = watch(
      () => toValue(collectionEditorRef.value?.editor?.collections),
      (cols) => {
        if (cols && cols.length > 0) {
          proposalTriggered.value = true
          checkEditor()
        }
      },
      { immediate: true }
    )
  }
}, { immediate: true })

async function continueToSeedData() {
  const id = await ensureProject()

  // Snapshot collections for seed data phase
  const editor = collectionEditorRef.value?.editor
  if (editor) {
    seedDataCollections.value = toValue(editor.collectionsWithFields) || []
  }

  await $fetch(buildApiUrl(`/designer-projects/${id}`), {
    method: 'PATCH',
    body: { currentPhase: '3' }
  })
  insertPhaseMarker('3')
  currentPhase.value = '3'
  triggerSeedDataGeneration()
}

// --- Auto-generate seed data on Phase 3 entry ---
const seedGenTriggered = ref(false)

function triggerSeedDataGeneration() {
  if (seedGenTriggered.value) return
  // Only auto-generate if no seed data exists yet
  if (Object.keys(seedData.value).length > 0) {
    seedGenTriggered.value = true
    return
  }
  seedGenTriggered.value = true
  const collectionNames = seedDataCollections.value.map(c => c.name).join(', ')
  append({
    id: crypto.randomUUID(),
    role: 'user',
    content: `Generate realistic seed data for all collections: ${collectionNames}. Create 5-10 entries per collection with meaningful cross-references.`
  })
}

// Load collections for seed data phase when loading an existing project in Phase 3
watch(currentPhase, async (phase) => {
  if (phase === '3' && seedDataCollections.value.length === 0) {
    // Need to load collections from DB for the seed data prompt
    const collections = await $fetch<any[]>(buildApiUrl(`/designer-collections?projectId=${projectId.value}`))
    const fields = await $fetch<any[]>(buildApiUrl(`/designer-fields?projectId=${projectId.value}`))
    if (collections && fields) {
      seedDataCollections.value = collections.map(col => ({
        ...col,
        fields: fields.filter(f => f.collectionId === col.id).sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0))
      }))
    }
  }
}, { immediate: true })

function handleRegenerateSeedData(collectionName: string) {
  append({
    id: crypto.randomUUID(),
    role: 'user',
    content: `Regenerate seed data for the "${collectionName}" collection. Keep data for other collections unchanged.`
  })
}

async function continueToReview() {
  const id = await ensureProject()
  await $fetch(buildApiUrl(`/designer-projects/${id}`), {
    method: 'PATCH',
    body: { currentPhase: '5' }
  })
  insertPhaseMarker('5')
  currentPhase.value = '5'
}
</script>

<template>
  <UDashboardPanel>
    <template #header>
      <UDashboardNavbar :title="projectConfig.name || 'New Project'">
        <template #leading>
          <UDashboardSidebarCollapse />
          <UButton
            icon="i-lucide-arrow-left"
            variant="ghost"
            color="neutral"
            :to="`/admin/${teamSlug}/designer`"
          />
        </template>
      </UDashboardNavbar>
    </template>

    <template #body>
      <div class="max-w-7xl mx-auto px-4 py-6">
        <div class="flex gap-4 h-[calc(100vh-14rem)]">
          <!-- Left: Persistent chat (collapsible) -->
          <div
            v-show="!chatCollapsed"
            class="w-1/3 min-w-80 flex flex-col border border-[var(--ui-border)] rounded-lg overflow-hidden"
          >
            <div class="flex items-center justify-between px-3 py-2 border-b border-[var(--ui-border)] bg-[var(--ui-bg-elevated)]">
              <span class="text-sm font-medium">Chat</span>
              <UButton
                icon="i-lucide-panel-left-close"
                variant="ghost"
                color="neutral"
                size="xs"
                @click="chatCollapsed = true"
              />
            </div>
            <div class="flex-1 overflow-hidden">
              <DesignerChatPanel
                :messages="messages"
                :is-loading="isLoading"
                :error="error"
                @send="handleChatSend"
                @retry="handleChatRetry"
              />
            </div>
          </div>

          <!-- Expand button when collapsed -->
          <div v-if="chatCollapsed" class="flex flex-col">
            <UButton
              icon="i-lucide-panel-left-open"
              variant="ghost"
              color="neutral"
              size="xs"
              @click="chatCollapsed = false"
            />
          </div>

          <!-- Right: Stepper + content -->
          <div class="flex-1 min-w-0 flex flex-col overflow-auto">
            <UStepper
              :model-value="currentPhase"
              :items="phases"
              :linear="false"
              class="mb-4"
              @update:model-value="handlePhaseChange"
            >
              <!-- Phase 1: Intake -->
              <template #intake>
                <!-- AI fallback notice -->
                <UAlert
                  v-if="error"
                  color="warning"
                  variant="subtle"
                  icon="i-lucide-info"
                  :description="t('designer.chat.aiFallback')"
                  class="mx-4 mt-4"
                />

                <DesignerIntakeSummaryCard
                  :config="projectConfig"
                  @update:config="updateConfig"
                />

                <!-- Transition button -->
                <div class="px-6 pb-6">
                  <USeparator class="mb-6" />
                  <div class="flex items-center justify-between">
                    <p v-if="!canContinue" class="text-sm text-[var(--ui-text-muted)]">
                      {{ t('designer.project.setNameAndType') }}
                    </p>
                    <div v-else />
                    <UButton
                      :label="t('designer.project.continueToCollections')"
                      icon="i-lucide-arrow-right"
                      trailing
                      :disabled="!canContinue"
                      @click="continueToCollections"
                    />
                  </div>
                </div>
              </template>

              <!-- Phase 2: Collection Design -->
              <template #collections>
                <DesignerCollectionEditor
                  ref="collectionEditorRef"
                  :project-id="projectId"
                />

                <!-- Transition button -->
                <div class="px-4 pb-4">
                  <USeparator class="mb-4" />
                  <div class="flex items-center justify-end">
                    <UButton
                      :label="t('designer.project.continueToSeedData')"
                      icon="i-lucide-arrow-right"
                      trailing
                      @click="continueToSeedData"
                    />
                  </div>
                </div>
              </template>

              <!-- Phase 3: Seed Data -->
              <template #seed-data>
                <DesignerSeedDataPanel
                  :collections="seedDataCollections"
                  :seed-data="seedData"
                  @regenerate="handleRegenerateSeedData"
                />

                <!-- Transition button -->
                <div class="px-4 pb-4">
                  <USeparator class="mb-4" />
                  <div class="flex items-center justify-end">
                    <UButton
                      :label="t('designer.project.continueToReview')"
                      icon="i-lucide-arrow-right"
                      trailing
                      @click="continueToReview"
                    />
                  </div>
                </div>
              </template>

              <!-- Phase 5: Review & Generate -->
              <template #review>
                <DesignerReviewPanel
                  :project-id="projectId"
                  :config="projectConfig"
                  @back-to-collections="handlePhaseChange('2')"
                />
              </template>
            </UStepper>
          </div>
        </div>

        <!-- Backward navigation warning -->
        <UModal v-model="showBackwardWarning">
          <template #content>
            <div class="p-6">
              <div class="flex items-center gap-3 mb-4">
                <UIcon name="i-lucide-alert-triangle" class="size-5 text-[var(--ui-color-warning-500)]" />
                <h3 class="text-lg font-semibold">
                  {{ t('designer.project.goBackToIntake') }}
                </h3>
              </div>
              <p class="text-sm text-[var(--ui-text-muted)] mb-6">
                {{ t('designer.project.goBackWarning') }}
              </p>
              <div class="flex justify-end gap-2">
                <UButton color="neutral" variant="ghost" :label="t('common.cancel')" @click="cancelBackward" />
                <UButton color="warning" :label="t('designer.project.goBack')" @click="confirmBackward" />
              </div>
            </div>
          </template>
        </UModal>

        <!-- Cascade delete warning (Phase 3+ → Phase 2) -->
        <UModal v-model="showCascadeWarning">
          <template #content>
            <div class="p-6">
              <div class="flex items-center gap-3 mb-4">
                <UIcon name="i-lucide-alert-triangle" class="size-5 text-[var(--ui-color-warning-500)]" />
                <h3 class="text-lg font-semibold">
                  {{ t('designer.project.goBackToCollections') }}
                </h3>
              </div>
              <p class="text-sm text-[var(--ui-text-muted)] mb-6">
                {{ t('designer.project.goBackToCollectionsWarning') }}
              </p>
              <div class="flex justify-end gap-2">
                <UButton color="neutral" variant="ghost" :label="t('common.cancel')" @click="cancelCascadeDelete" />
                <UButton color="warning" :label="t('designer.project.clearSeedData')" @click="confirmCascadeDelete" />
              </div>
            </div>
          </template>
        </UModal>
      </div>
    </template>
  </UDashboardPanel>
</template>
