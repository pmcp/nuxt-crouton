/**
 * Export events endpoint for audit log compliance
 *
 * Supports:
 * - Format: ?format=csv|json (default: json)
 * - Filters: ?collectionName=X&operation=X&userId=X&dateFrom=X&dateTo=X
 *
 * Response:
 * - CSV: Returns text/csv with headers
 * - JSON: Returns array of events
 */
import { eq, and, gte, lte } from 'drizzle-orm'
import { resolveTeamAndCheckMembership } from '@friendlyinternet/nuxt-crouton-auth/server/utils/team'

export default defineEventHandler(async (event) => {
  // Authenticate and check team membership
  const { team } = await resolveTeamAndCheckMembership(event)
  const db = useDB()

  // Parse query parameters
  const query = getQuery(event)
  const format = (query.format as 'csv' | 'json') || 'json'
  const collectionName = query.collectionName as string | undefined
  const operation = query.operation as 'create' | 'update' | 'delete' | undefined
  const userId = query.userId as string | undefined
  const dateFrom = query.dateFrom ? new Date(String(query.dateFrom)) : undefined
  const dateTo = query.dateTo ? new Date(String(query.dateTo)) : undefined

  // Get the events table - dynamically import the schema
  // The schema is generated by the collection generator
  let eventsTable: any
  try {
    // Try to import the generated events schema
    const schema = await import('~~/layers/events/collections/collectionEvents/server/database/schema')
    eventsTable = schema.eventsCollectionEvents || schema.collectionEvents
  } catch {
    // Fallback for when the layer is named differently
    try {
      const schema = await import('~~/collections/croutonEvents/server/database/schema')
      eventsTable = schema.croutonEvents
    } catch {
      throw createError({
        statusCode: 500,
        statusMessage: 'Events collection not found. Make sure the events collection is generated.'
      })
    }
  }

  // Build where conditions
  const conditions = [
    eq(eventsTable.teamId, team.id)
  ]

  if (collectionName) {
    conditions.push(eq(eventsTable.collectionName, collectionName))
  }
  if (operation) {
    conditions.push(eq(eventsTable.operation, operation))
  }
  if (userId) {
    conditions.push(eq(eventsTable.userId, userId))
  }
  if (dateFrom && !isNaN(dateFrom.getTime())) {
    conditions.push(gte(eventsTable.timestamp, dateFrom))
  }
  if (dateTo && !isNaN(dateTo.getTime())) {
    conditions.push(lte(eventsTable.timestamp, dateTo))
  }

  // Query events
  const events = await db
    .select()
    .from(eventsTable)
    .where(and(...conditions))
    .orderBy(eventsTable.timestamp)

  // Return based on format
  if (format === 'csv') {
    // Generate CSV
    const headers = [
      'timestamp',
      'operation',
      'collectionName',
      'itemId',
      'userId',
      'userName',
      'changes',
      'metadata'
    ]

    const rows = events.map((e: any) => [
      new Date(e.timestamp).toISOString(),
      e.operation,
      e.collectionName,
      e.itemId,
      e.userId,
      e.userName || '',
      JSON.stringify(e.changes || []),
      JSON.stringify(e.metadata || {})
    ])

    const csvContent = [
      headers.join(','),
      ...rows.map((row: string[]) => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
    ].join('\n')

    setHeader(event, 'Content-Type', 'text/csv')
    setHeader(event, 'Content-Disposition', `attachment; filename="audit-log-${new Date().toISOString().split('T')[0]}.csv"`)

    return csvContent
  }

  // Default: JSON format
  return events
})
