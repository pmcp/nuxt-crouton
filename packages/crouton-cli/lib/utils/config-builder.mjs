// config-builder.mjs — Build crouton.config.js content from schemas and options.
// Shared between the CLI and the designer's scaffold endpoint.

/**
 * Build crouton.config.js file content from structured input.
 *
 * @param {Object} options
 * @param {string} options.appName - App name (used as default layer name)
 * @param {string[]} [options.packages] - Package names to enable as features
 * @param {Record<string, any>} [options.schemas] - Map of collection name → schema (used to derive collection list)
 * @param {Record<string, any[]>} [options.seedData] - Map of collection name → seed entries
 * @param {string} [options.dialect='sqlite'] - Database dialect
 * @returns {string} crouton.config.js file content
 */
export function buildCroutonConfig(options) {
  const {
    appName,
    packages = [],
    schemas = {},
    seedData = {},
    dialect = 'sqlite'
  } = options

  // Build features object (non-bundled only)
  const bundled = new Set(['auth', 'admin', 'i18n'])
  const features = {}
  for (const pkg of packages) {
    if (!bundled.has(pkg)) {
      features[pkg] = true
    }
  }

  const featuresStr = Object.entries(features)
    .map(([k, v]) => `    ${k}: ${v}`)
    .join(',\n')

  // Build collections array from schemas
  const collectionNames = Object.keys(schemas)

  const collectionsStr = collectionNames.map((name) => {
    const opts = [
      `name: '${name}'`,
      `fieldsFile: './schemas/${name}.json'`
    ]

    // Add seed option if seed data exists for this collection
    if (seedData[name] && seedData[name].length > 0) {
      opts.push('seed: true')
    }

    return `    { ${opts.join(', ')} }`
  }).join(',\n')

  // Build targets — group all collections into a single layer named after the app
  const targetsStr = `    { layer: '${appName}', collections: [${collectionNames.map(n => `'${n}'`).join(', ')}] }`

  return `export default {
  // Feature flags - which crouton packages to enable
  features: {
${featuresStr ? featuresStr + '\n' : ''}  },

  // Collections generated by Schema Designer
  collections: [
${collectionsStr}
  ],

  // Target layers
  targets: [
${targetsStr}
  ],

  dialect: '${dialect}'
}
`
}
