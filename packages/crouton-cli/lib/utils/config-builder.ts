// config-builder.ts — Build crouton.config.js content from schemas and options.
// Shared between the CLI and the designer's scaffold endpoint.

interface ConfigBuilderOptions {
  appName: string
  packages?: string[]
  schemas?: Record<string, unknown>
  seedData?: Record<string, unknown[]>
  dialect?: string
}

/**
 * Build crouton.config.js file content from structured input.
 */
export function buildCroutonConfig(options: ConfigBuilderOptions): string {
  const {
    appName,
    packages = [],
    schemas = {},
    seedData = {},
    dialect = 'sqlite',
  } = options

  // Build features object (non-bundled only)
  const bundled = new Set(['auth', 'admin', 'i18n'])
  const features: Record<string, boolean> = {}
  for (const pkg of packages) {
    if (!bundled.has(pkg)) {
      features[pkg] = true
    }
  }

  const featuresStr = Object.entries(features)
    .map(([k, v]) => `    ${k}: ${v}`)
    .join(',\n')

  // Build collections array from schemas
  const collectionNames = Object.keys(schemas)

  const collectionsStr = collectionNames.map((name) => {
    const opts = [
      `name: '${name}'`,
      `fieldsFile: './schemas/${name}.json'`,
    ]

    // Add seed option if seed data exists for this collection
    if (seedData[name] && seedData[name].length > 0) {
      opts.push('seed: true')
    }

    return `    { ${opts.join(', ')} }`
  }).join(',\n')

  // Build targets — group all collections into a single layer named after the app
  const targetsStr = `    { layer: '${appName}', collections: [${collectionNames.map(n => `'${n}'`).join(', ')}] }`

  return `export default {
  // Feature flags - which crouton packages to enable
  features: {
${featuresStr ? featuresStr + '\n' : ''}  },

  // Collections generated by Schema Designer
  collections: [
${collectionsStr}
  ],

  // Target layers
  targets: [
${targetsStr}
  ],

  dialect: '${dialect}'
}
`
}
