// Generator for TypeScript types
import { toCase } from '../utils/helpers.ts'

/**
 * Generate AI context header for types files
 */
function generateAIHeader(data) {
  const { plural, layer, layerPascalCase, pascalCase, pascalCasePlural, fields } = data
  const prefixedPascalCase = `${layerPascalCase}${pascalCase}`
  const fieldNames = fields.map(f => f.name).join(', ')

  return `/**
 * @crouton-generated
 * @collection ${plural}
 * @layer ${layer}
 * @generated ${new Date().toISOString().split('T')[0]}
 *
 * ## AI Context
 * - Main interface: ${prefixedPascalCase}
 * - Form data type: ${prefixedPascalCase}FormData
 * - New item type: New${prefixedPascalCase}
 * - Form props: ${prefixedPascalCase}FormProps
 * - Fields: ${fieldNames}
 *
 * ## Common Modifications
 * - Add field: Add to interface and ensure schema matches
 * - Change field type: Update both interface and schema
 * - Add computed field: Add optional property to interface
 *
 * This file was generated by @fyit/crouton-cli
 * Safe to modify - regeneration requires --force flag
 */

`
}

/**
 * Generate item interface for a translatable repeater field
 * When meta.translatableProperties is present, generates interface with translations support
 */
function generateRepeaterItemInterface(field, layerPascalCase, pascalCasePlural) {
  const { pascalCase: fieldPascalCase } = toCase(field.name)
  const interfaceName = `${layerPascalCase}${pascalCasePlural}${fieldPascalCase}Item`

  const translatableProps = field.meta?.translatableProperties || []
  const properties = field.meta?.properties || {}

  // Generate property lines
  const propertyLines = []

  // Always add id
  propertyLines.push('  id: string')

  // Add all properties from meta.properties
  for (const [propName, propDef] of Object.entries(properties)) {
    const isRequired = propDef.required === true
    const tsType = mapPropertyType(propDef.type)
    propertyLines.push(`  ${propName}${isRequired ? '' : '?'}: ${tsType}`)
  }

  // Add translations property if there are translatable properties
  if (translatableProps.length > 0) {
    const translationFields = translatableProps.map(prop => `    ${prop}?: Record<string, string>`).join('\n')
    propertyLines.push(`  translations?: {\n${translationFields}\n  }`)
  }

  return `export interface ${interfaceName} {
${propertyLines.join('\n')}
}`
}

/**
 * Map property type to TypeScript type
 */
function mapPropertyType(type) {
  const typeMap = {
    string: 'string',
    text: 'string',
    number: 'number',
    decimal: 'number',
    boolean: 'boolean',
    date: 'Date | null',
    json: 'Record<string, any>',
    array: 'string[]'
  }
  return typeMap[type] || 'string'
}

export function generateTypes(data, config = null) {
  const { pascalCase, pascalCasePlural, layerPascalCase, layerCamelCase, singular, layer, plural, fields } = data
  const prefixedPascalCase = `${layerPascalCase}${pascalCase}`
  const prefixedPascalCasePlural = `${layerPascalCase}${pascalCasePlural}`
  const prefixedSingular = `${layerCamelCase}${pascalCase}`

  const composablePath = `./app/composables/use${prefixedPascalCasePlural}`

  // Conditional field generation based on config flags
  // Team fields are always required (all generated endpoints use @crouton/auth)
  const useMetadata = config?.flags?.useMetadata ?? true

  // Check if this collection has translations
  const hasTranslations = config?.translations?.collections?.[plural] || config?.translations?.collections?.[singular]
  const translationFields = hasTranslations ? Array.isArray(hasTranslations) ? hasTranslations : [] : []

  // Team fields are always included (required for @crouton/auth)
  const teamFields = `  teamId: string
  owner: string
`

  // Build metadata fields conditionally
  const metadataFields = useMetadata
    ? `  createdAt: Date
  updatedAt: Date
  createdBy: string
  updatedBy: string
`
    : ''

  // Build translations type if needed
  const translationsType = translationFields.length > 0
    ? `  translations?: Record<string, { ${translationFields.map(f => `${f}?: string`).join('; ')} }>
  locale?: string
`
    : ''

  // Build the omit list for New${prefixedPascalCase} type
  const omitFields = ['id']
  if (useMetadata) {
    omitFields.push('createdAt', 'updatedAt', 'createdBy', 'updatedBy')
  }
  const omitList = omitFields.map(f => `'${f}'`).join(' | ')

  // Generate AI context header
  const aiHeader = generateAIHeader(data)

  // Find repeater fields with translatableProperties and generate their item interfaces
  const repeaterItemInterfaces = fields
    .filter(f => f.type === 'repeater' && (f.meta?.translatableProperties || f.meta?.properties))
    .map(f => generateRepeaterItemInterface(f, layerPascalCase, pascalCasePlural))
    .join('\n\n')

  const repeaterInterfacesBlock = repeaterItemInterfaces
    ? `${repeaterItemInterfaces}\n\n`
    : ''

  return `${aiHeader}import type { z } from 'zod'
import type { ${prefixedSingular}Schema } from '${composablePath}'

${repeaterInterfacesBlock}export interface ${prefixedPascalCase} {
  id: string
${teamFields}  ${data.fieldsTypes}
${translationsType}${metadataFields}  optimisticId?: string
  optimisticAction?: 'create' | 'update' | 'delete'
}

export type ${prefixedPascalCase}FormData = z.infer<typeof ${prefixedSingular}Schema>
export type New${prefixedPascalCase} = Omit<${prefixedPascalCase}, ${omitList}>

// Props type for the Form component
export interface ${prefixedPascalCase}FormProps {
  items: string[] // Array of IDs for delete action
  activeItem: ${prefixedPascalCase} | Record<string, never> // ${prefixedPascalCase} for update, empty object for create
  collection: string
  loading: string
  action: 'create' | 'update' | 'delete'
}`
}
