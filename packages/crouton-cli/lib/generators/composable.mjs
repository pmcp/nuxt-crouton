// Generator for use[Collection].ts composable
import { toCase } from '../utils/helpers.mjs'

/**
 * Generate Zod schema for a repeater item with optional translatable properties
 * When meta.translatableProperties is present, includes translations validation
 */
function generateRepeaterItemSchema(field, layerCamelCase, pascalCasePlural) {
  const { pascalCase: fieldPascalCase, camelCase: fieldCamelCase } = toCase(field.name)
  const schemaName = `${layerCamelCase}${pascalCasePlural}${fieldPascalCase}ItemSchema`

  const translatableProps = field.meta?.translatableProperties || []
  const properties = field.meta?.properties || {}

  // Generate schema fields
  const schemaFields = []

  // Always add id
  schemaFields.push('id: z.string()')

  // Add all properties from meta.properties
  for (const [propName, propDef] of Object.entries(properties)) {
    const zodType = mapPropertyToZod(propDef)
    if (propDef.required === true) {
      schemaFields.push(`${propName}: ${zodType}`)
    } else {
      schemaFields.push(`${propName}: ${zodType}.optional()`)
    }
  }

  // Add translations schema if there are translatable properties
  if (translatableProps.length > 0) {
    const translationFields = translatableProps.map(prop => `      ${prop}: z.string().optional()`).join(',\n')
    schemaFields.push(`translations: z.record(z.string(), z.object({\n${translationFields}\n    })).optional()`)
  }

  return {
    name: schemaName,
    code: `export const ${schemaName} = z.object({
  ${schemaFields.join(',\n  ')}
})`
  }
}

/**
 * Map property type to Zod schema
 */
function mapPropertyToZod(propDef) {
  const type = propDef.type || 'string'
  const zodMap = {
    string: 'z.string()',
    text: 'z.string()',
    number: 'z.number()',
    decimal: 'z.number()',
    boolean: 'z.boolean()',
    date: 'z.date()',
    json: 'z.record(z.string(), z.any())',
    array: 'z.array(z.string())'
  }
  return zodMap[type] || 'z.string()'
}

/**
 * Generate AI context header for composable files
 */
function generateAIHeader(data, apiPath) {
  const { singular, plural, layerPascalCase, layerCamelCase, pascalCasePlural, layer, fields } = data
  const fieldNames = fields.map(f => f.name).join(', ')
  // Use layerCamelCase for proper camelCase collection names (e.g., "knowledge-base" -> "knowledgeBase")
  const prefixedPlural = `${layerCamelCase}${pascalCasePlural}`

  return `/**
 * @crouton-generated
 * @collection ${plural}
 * @layer ${layer}
 * @generated ${new Date().toISOString().split('T')[0]}
 *
 * ## AI Context
 * - Composable: use${layerPascalCase}${pascalCasePlural}
 * - Collection name: ${prefixedPlural}
 * - API endpoint: /api/teams/[id]/${apiPath}
 * - Form component: ${layerPascalCase}${pascalCasePlural}Form
 * - List component: ${layerPascalCase}${pascalCasePlural}List
 * - Fields: ${fieldNames}
 *
 * ## Common Modifications
 * - Add field: Add to schema object and defaultValues
 * - Change validation: Modify z.object() schema
 * - Add column: Add to columns array
 * - Change API path: Modify apiPath in config
 *
 * This file was generated by @fyit/crouton-cli
 * Safe to modify - regeneration requires --force flag
 */

`
}

export function generateComposable(data, config = {}) {
  const { singular, plural, pascalCase, pascalCasePlural, layerPascalCase, layerCamelCase, layer, fields, hierarchy, sortable } = data
  // Use layerCamelCase for proper camelCase collection names (e.g., "knowledge-base" -> "knowledgeBase")
  const prefixedSingular = `${layerCamelCase}${pascalCase}`
  const prefixedPlural = `${layerCamelCase}${pascalCasePlural}`
  const prefixedPascalCasePlural = `${layerPascalCase}${pascalCasePlural}`

  // Create kebab-case API path with layer prefix
  const apiPath = `${layer}-${plural}`

  // Runtime component handles default columns (created_at, updated_at, actions)
  const columns = data.fieldsColumns

  // Detect dependent fields and build dependentFieldComponents map
  const dependentFieldComponents = {}
  fields.forEach((field) => {
    // Register Select components for: repeater fields, slotButtonGroup, or dependent fields
    if (field.type === 'repeater' || field.meta?.displayAs === 'slotButtonGroup' || field.meta?.dependsOn) {
      // Generate component name with full prefix: LayerCollectionFieldSelect
      const { pascalCase: fieldPascalCase } = toCase(field.name)
      dependentFieldComponents[field.name] = `${layerPascalCase}${pascalCasePlural}${fieldPascalCase}Select`
    }
  })

  const hasDependentFields = Object.keys(dependentFieldComponents).length > 0

  // Generate dependentFieldComponents config if needed
  const dependentFieldComponentsCode = hasDependentFields
    ? `,\n  dependentFieldComponents: {\n${Object.entries(dependentFieldComponents).map(([field, component]) => `    ${field}: '${component}'`).join(',\n')}\n  }`
    : ''

  // Generate hierarchy config if enabled
  const hierarchyConfigCode = hierarchy?.enabled
    ? `,\n  hierarchy: {
    enabled: true,
    parentField: '${hierarchy.parentField || 'parentId'}',
    pathField: '${hierarchy.pathField || 'path'}',
    depthField: '${hierarchy.depthField || 'depth'}',
    orderField: '${hierarchy.orderField || 'order'}'
  }`
    : ''

  // Generate sortable config if enabled (flat ordering without hierarchy)
  // Only output if sortable is enabled AND hierarchy is NOT enabled
  const sortableConfigCode = sortable?.enabled && !hierarchy?.enabled
    ? `,\n  sortable: {
    enabled: true,
    orderField: '${sortable.orderField || 'order'}'
  }`
    : ''

  // Generate AI context header
  const aiHeader = generateAIHeader(data, apiPath)

  // Compute form component name - use custom formComponent from config or generate default
  const formComponentName = data.collectionConfig?.formComponent || `${layerPascalCase}${pascalCasePlural}Form`

  // Generate item schemas for repeater fields with translatableProperties or properties
  const repeaterItemSchemas = fields
    .filter(f => f.type === 'repeater' && (f.meta?.translatableProperties || f.meta?.properties))
    .map(f => generateRepeaterItemSchema(f, layerCamelCase, pascalCasePlural))

  const itemSchemasCode = repeaterItemSchemas.length > 0
    ? repeaterItemSchemas.map(s => s.code).join('\n\n') + '\n\n'
    : ''

  return `${aiHeader}import { z } from 'zod'

${itemSchemasCode}// Schema exported separately - Zod 4 schemas cannot survive deep cloning
// Keep schema outside of objects that might be serialized/cloned during SSR
export const ${prefixedSingular}Schema = z.object({
  ${data.fieldsSchema}
})

export const ${prefixedPlural}Columns = [
  ${columns}
]

// Config object WITHOUT schema - safe for SSR serialization
const _${prefixedPlural}Config = {
  name: '${prefixedPlural}',
  layer: '${layer}',
  apiPath: '${apiPath}',
  componentName: '${formComponentName}',
  defaultValues: {
    ${data.fieldsDefault}
  },
  columns: ${prefixedPlural}Columns${dependentFieldComponentsCode}${hierarchyConfigCode}${sortableConfigCode},
}

// Add schema as non-enumerable property so klona skips it during cloning
Object.defineProperty(_${prefixedPlural}Config, 'schema', {
  value: ${prefixedSingular}Schema,
  enumerable: false,
  configurable: false,
  writable: false
})

export const ${prefixedPlural}Config = _${prefixedPlural}Config as typeof _${prefixedPlural}Config & { schema: typeof ${prefixedSingular}Schema }

export const use${prefixedPascalCasePlural} = () => ${prefixedPlural}Config

// Default export for auto-import compatibility
export default function () {
  return {
    defaultValue: ${prefixedPlural}Config.defaultValues,
    schema: ${prefixedSingular}Schema,
    columns: ${prefixedPlural}Config.columns,
    collection: ${prefixedPlural}Config.name
  }
}`
}
