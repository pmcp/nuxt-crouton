/**
 * Generator for collection type registry
 *
 * Scans all layers and collections to generate a type declaration file
 * that augments the CollectionTypeMap interface for type-safe CRUD operations.
 *
 * Output location: types/crouton-collections.d.ts (in project root)
 */

import fsp from 'node:fs/promises'
import path from 'node:path'

/**
 * Check if a path exists
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fsp.access(filePath)
    return true
  } catch {
    return false
  }
}

/**
 * Get all layers that have collections
 */
async function getAllLayers(basePath: string = '.'): Promise<string[]> {
  const layersPath = path.resolve(basePath, 'layers')

  if (!await fileExists(layersPath)) {
    return []
  }

  const entries = await fsp.readdir(layersPath, { withFileTypes: true })
  const layers = []

  for (const entry of entries) {
    if (!entry.isDirectory()) continue

    const collectionsPath = path.join(layersPath, entry.name, 'collections')
    if (await fileExists(collectionsPath)) {
      layers.push(entry.name)
    }
  }

  return layers
}

/**
 * Get all collections in a layer
 */
async function getCollectionsInLayer(layer: string, basePath: string = '.'): Promise<string[]> {
  const collectionsPath = path.resolve(basePath, 'layers', layer, 'collections')

  if (!await fileExists(collectionsPath)) {
    return []
  }

  const entries = await fsp.readdir(collectionsPath, { withFileTypes: true })
  return entries
    .filter(entry => entry.isDirectory())
    .map(entry => entry.name)
}

/**
 * Convert a string to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('')
}

/**
 * Convert a string to camelCase
 */
function toCamelCase(str: string): string {
  const pascal = toPascalCase(str)
  return pascal.charAt(0).toLowerCase() + pascal.slice(1)
}

/**
 * Get singular form (simple heuristic)
 */
function toSingular(plural: string): string {
  if (plural.endsWith('ies')) {
    return plural.slice(0, -3) + 'y'
  }
  if (plural.endsWith('es') && (plural.endsWith('sses') || plural.endsWith('xes') || plural.endsWith('ches') || plural.endsWith('shes'))) {
    return plural.slice(0, -2)
  }
  if (plural.endsWith('s') && !plural.endsWith('ss')) {
    return plural.slice(0, -1)
  }
  return plural
}

/**
 * Discover all collections and their type information
 */
export async function discoverCollections(basePath: string = '.'): Promise<Record<string, any>[]> {
  const layers = await getAllLayers(basePath)
  const collections = []

  for (const layer of layers) {
    const layerCollections = await getCollectionsInLayer(layer, basePath)

    for (const collection of layerCollections) {
      const typesPath = path.resolve(basePath, 'layers', layer, 'collections', collection, 'types.ts')

      // Check if types.ts exists
      if (!await fileExists(typesPath)) {
        console.warn(`Warning: No types.ts found for ${layer}/${collection}`)
        continue
      }

      // Extract naming info
      const layerPascal = toPascalCase(layer)
      const singular = toSingular(collection)
      const singularPascal = toPascalCase(singular)

      // The generated type names follow this pattern:
      // Interface: {LayerPascal}{SingularPascal} (e.g., BlogPost)
      // FormData: {LayerPascal}{SingularPascal}FormData (e.g., BlogPostFormData)
      // NewItem: New{LayerPascal}{SingularPascal} (e.g., NewBlogPost)
      const typeName = `${layerPascal}${singularPascal}`

      // The collection key used in composables
      // Uses camelCase: {layer}{Collection} (e.g., blogPosts)
      const collectionKey = `${toCamelCase(layer)}${toPascalCase(collection)}`

      collections.push({
        layer,
        collection,
        typesPath: `./layers/${layer}/collections/${collection}/types`,
        typeName,
        formDataType: `${typeName}FormData`,
        newItemType: `New${typeName}`,
        collectionKey
      })
    }
  }

  return collections
}

/**
 * Generate the type registry declaration file content
 */
export function generateTypeRegistry(collections: Record<string, any>[]): string {
  if (collections.length === 0) {
    return `/**
 * @crouton-generated
 * Collection Type Registry
 *
 * This file is auto-generated by @fyit/crouton-cli
 * Run \`crouton sync-types\` to regenerate after adding collections.
 *
 * No collections found. Generate some collections first!
 */

export {}
`
  }

  // Generate imports
  const imports = collections.map(col =>
    `import type { ${col.typeName}, ${col.formDataType}, ${col.newItemType} } from '${col.typesPath}'`
  ).join('\n')

  // Generate type map entries
  const typeMapEntries = collections.map(col =>
    `    ${col.collectionKey}: {
      Item: ${col.typeName}
      FormData: ${col.formDataType}
      NewItem: ${col.newItemType}
    }`
  ).join('\n')

  return `/**
 * @crouton-generated
 * Collection Type Registry
 *
 * This file is auto-generated by @fyit/crouton-cli
 * Run \`crouton sync-types\` to regenerate after adding collections.
 *
 * Generated: ${new Date().toISOString().split('T')[0]}
 *
 * ## How This Works
 * This file augments the CollectionTypeMap interface from @crouton/types.
 * When you use useCollectionQuery('blogPosts'), TypeScript automatically
 * knows the return type is BlogPost[] without requiring explicit generics.
 *
 * ## Registered Collections
${collections.map(col => ` * - ${col.collectionKey}: ${col.typeName}`).join('\n')}
 */

${imports}

declare module '#crouton/types' {
  interface CollectionTypeMap {
${typeMapEntries}
  }
}

export {}
`
}

/**
 * Main function to generate the type registry file
 */
export async function generateCollectionTypesRegistry(basePath: string = '.', outputPath: string | null = null): Promise<{ outputPath: string; collectionsCount: number; collections: Record<string, any>[] }> {
  const collections = await discoverCollections(basePath)

  const content = generateTypeRegistry(collections)

  // Default output location
  const finalOutputPath = outputPath || path.resolve(basePath, 'types', 'crouton-collections.d.ts')

  // Ensure types directory exists
  await fsp.mkdir(path.dirname(finalOutputPath), { recursive: true })

  // Write the file
  await fsp.writeFile(finalOutputPath, content, 'utf-8')

  return {
    outputPath: finalOutputPath,
    collectionsCount: collections.length,
    collections
  }
}
