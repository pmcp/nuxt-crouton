// Define a type for collection names (will be extended by user's registry)
type CollectionName = string

/** Display config: maps display roles to field names */
interface DisplayConfig {
  /** Primary identifier field name */
  title?: string
  /** Secondary context field name */
  subtitle?: string
  /** Visual identifier field name (image/asset type) */
  image?: string
  /** Status/category indicator field name */
  badge?: string
  /** Summary text field name */
  description?: string
}

/** Lightweight runtime field metadata for display components */
interface RuntimeFieldMeta {
  name: string
  type: string
  label: string
  area?: 'main' | 'sidebar' | 'meta'
  displayAs?: string
}

// Type for config map entries supplied via app.config.ts
interface CollectionConfig {
  name?: string
  layer?: string
  componentName?: string
  apiPath?: string
  displayName?: string
  defaultPagination?: {
    currentPage: number
    pageSize: number
    sortBy: string
    sortDirection: 'asc' | 'desc'
  }
  /**
   * Declare which fields reference other collections.
   * Enables automatic cache refresh of referenced items during mutations.
   *
   * @example
   * references: {
   *   location: 'bookingsLocations',  // 'location' field references 'bookingsLocations' collection
   *   author: 'users'                 // 'author' field references 'users' collection
   * }
   */
  references?: Record<string, string>
  /**
   * Map field names to custom dependent field renderer components.
   * Used by FormDependentFieldLoader to dynamically load custom components.
   *
   * @example
   * dependentFieldComponents: {
   *   slots: 'SlotSelect'  // When rendering 'slots' field, use SlotSelect component
   * }
   */
  dependentFieldComponents?: Record<string, string>
  /**
   * Hierarchy configuration for tree-enabled collections.
   * Generated by CLI when collection uses --hierarchy flag.
   */
  hierarchy?: {
    enabled: boolean
    parentField?: string
    pathField?: string
    depthField?: string
    orderField?: string
  }
  /**
   * Sortable configuration for flat collections with ordering.
   * Generated by CLI when collection uses sortable config (without hierarchy).
   * Enables drag-drop reordering without parent-child nesting.
   */
  sortable?: {
    enabled: boolean
    orderField?: string
  }
  /**
   * Admin navigation configuration.
   * Controls how this collection appears in the admin sidebar.
   *
   * @example
   * adminNav: {
   *   enabled: true,           // Show in admin sidebar (default: true)
   *   icon: 'i-lucide-users',  // Lucide icon class
   *   label: 'Users',          // Override display name
   *   order: 10                // Sort order in navigation
   * }
   */
  adminNav?: {
    enabled?: boolean
    icon?: string
    label?: string
    order?: number
  }
  /**
   * Display config: maps display roles (title, image, badge, etc.) to field names.
   * Used by useDisplayConfig() and display components (Card, Detail, CardMini).
   */
  display?: DisplayConfig
  /**
   * Runtime field metadata for display components.
   * Lightweight projection of schema fields: name, type, label, area, displayAs.
   */
  fields?: RuntimeFieldMeta[]
  [key: string]: any
}

type ConfigsMap = {
  [K in CollectionName]?: CollectionConfig
}

/**
 * Collection configuration management
 * Collections are registered via the generator in app.config.ts
 *
 * NOTE: This composable now only manages configuration, not data state.
 * For data fetching, use useCollectionQuery()
 * For mutations, use useCollectionMutation()
 */
export default function useCollections() {
  // Get the registry from app.config â€“ each entry should provide config data
  const appConfig = useAppConfig()
  const collectionRegistry = (appConfig.croutonCollections || {}) as Record<string, CollectionConfig>

  // Build component map from configs so FormDynamicLoader can resolve forms
  const componentMap = reactive<Record<string, string>>({})
  Object.entries(collectionRegistry).forEach(([name, config]) => {
    if (config?.componentName) {
      componentMap[name] = config.componentName
    }
  })

  // Build dependent field component map for FormDependentFieldLoader
  const dependentFieldComponentMap = reactive<Record<string, Record<string, string>>>({})
  Object.entries(collectionRegistry).forEach(([name, config]) => {
    if (config?.dependentFieldComponents) {
      dependentFieldComponentMap[name] = config.dependentFieldComponents
    }
  })

  // Get config synchronously - returns undefined for collections without configs
  const getConfig = (name: string): CollectionConfig | undefined => {
    return collectionRegistry[name]
  }

  return {
    componentMap,
    dependentFieldComponentMap,
    getConfig,
    configs: collectionRegistry
  }
}
