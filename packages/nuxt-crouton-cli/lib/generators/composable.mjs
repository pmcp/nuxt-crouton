// Generator for use[Collection].ts composable
import { toCase } from '../utils/helpers.mjs'

/**
 * Generate AI context header for composable files
 */
function generateAIHeader(data, apiPath) {
  const { singular, plural, layerPascalCase, pascalCasePlural, layer, fields } = data
  const fieldNames = fields.map(f => f.name).join(', ')
  const prefixedPlural = `${layerPascalCase.toLowerCase()}${pascalCasePlural}`

  return `/**
 * @crouton-generated
 * @collection ${plural}
 * @layer ${layer}
 * @generated ${new Date().toISOString().split('T')[0]}
 *
 * ## AI Context
 * - Composable: use${layerPascalCase}${pascalCasePlural}
 * - Collection name: ${prefixedPlural}
 * - API endpoint: /api/teams/[id]/${apiPath}
 * - Form component: ${layerPascalCase}${pascalCasePlural}Form
 * - List component: ${layerPascalCase}${pascalCasePlural}List
 * - Fields: ${fieldNames}
 *
 * ## Common Modifications
 * - Add field: Add to schema object and defaultValues
 * - Change validation: Modify z.object() schema
 * - Add column: Add to columns array
 * - Change API path: Modify apiPath in config
 *
 * This file was generated by @friendlyinternet/nuxt-crouton-cli
 * Safe to modify - regeneration requires --force flag
 */

`
}

export function generateComposable(data, config = {}) {
  const { singular, plural, pascalCase, pascalCasePlural, layerPascalCase, layer, fields, hierarchy, sortable } = data
  const prefixedSingular = `${layerPascalCase.toLowerCase()}${pascalCase}`
  const prefixedPlural = `${layerPascalCase.toLowerCase()}${pascalCasePlural}`
  const prefixedPascalCasePlural = `${layerPascalCase}${pascalCasePlural}`

  // Create kebab-case API path with layer prefix
  const apiPath = `${layer}-${plural}`

  // Runtime component handles default columns (created_at, updated_at, actions)
  const columns = data.fieldsColumns

  // Detect dependent fields and build dependentFieldComponents map
  const dependentFieldComponents = {}
  fields.forEach((field) => {
    // Register Select components for: repeater fields, slotButtonGroup, or dependent fields
    if (field.type === 'repeater' || field.meta?.displayAs === 'slotButtonGroup' || field.meta?.dependsOn) {
      // Generate component name with full prefix: LayerCollectionFieldSelect
      const { pascalCase: fieldPascalCase } = toCase(field.name)
      dependentFieldComponents[field.name] = `${layerPascalCase}${pascalCasePlural}${fieldPascalCase}Select`
    }
  })

  const hasDependentFields = Object.keys(dependentFieldComponents).length > 0

  // Generate dependentFieldComponents config if needed
  const dependentFieldComponentsCode = hasDependentFields
    ? `,\n  dependentFieldComponents: {\n${Object.entries(dependentFieldComponents).map(([field, component]) => `    ${field}: '${component}'`).join(',\n')}\n  }`
    : ''

  // Generate hierarchy config if enabled
  const hierarchyConfigCode = hierarchy?.enabled
    ? `,\n  hierarchy: {
    enabled: true,
    parentField: '${hierarchy.parentField || 'parentId'}',
    pathField: '${hierarchy.pathField || 'path'}',
    depthField: '${hierarchy.depthField || 'depth'}',
    orderField: '${hierarchy.orderField || 'order'}'
  }`
    : ''

  // Generate sortable config if enabled (flat ordering without hierarchy)
  // Only output if sortable is enabled AND hierarchy is NOT enabled
  const sortableConfigCode = sortable?.enabled && !hierarchy?.enabled
    ? `,\n  sortable: {
    enabled: true,
    orderField: '${sortable.orderField || 'order'}'
  }`
    : ''

  // Generate AI context header
  const aiHeader = generateAIHeader(data, apiPath)

  return `${aiHeader}import { z } from 'zod'

// Schema exported separately - Zod 4 schemas cannot survive deep cloning
// Keep schema outside of objects that might be serialized/cloned during SSR
export const ${prefixedSingular}Schema = z.object({
  ${data.fieldsSchema}
})

export const ${prefixedPlural}Columns = [
  ${columns}
]

// Config object WITHOUT schema - safe for SSR serialization
const _${prefixedPlural}Config = {
  name: '${prefixedPlural}',
  layer: '${layer}',
  apiPath: '${apiPath}',
  componentName: '${layerPascalCase}${pascalCasePlural}Form',
  defaultValues: {
    ${data.fieldsDefault}
  },
  columns: ${prefixedPlural}Columns${dependentFieldComponentsCode}${hierarchyConfigCode}${sortableConfigCode},
}

// Add schema as non-enumerable property so klona skips it during cloning
Object.defineProperty(_${prefixedPlural}Config, 'schema', {
  value: ${prefixedSingular}Schema,
  enumerable: false,
  configurable: false,
  writable: false
})

export const ${prefixedPlural}Config = _${prefixedPlural}Config as typeof _${prefixedPlural}Config & { schema: typeof ${prefixedSingular}Schema }

export const use${prefixedPascalCasePlural} = () => ${prefixedPlural}Config

// Default export for auto-import compatibility
export default function () {
  return {
    defaultValue: ${prefixedPlural}Config.defaultValues,
    schema: ${prefixedSingular}Schema,
    columns: ${prefixedPlural}Config.columns,
    collection: ${prefixedPlural}Config.name
  }
}`
}
