---
title: Frequently Asked Questions
description: Common questions and answers about Nuxt Crouton
icon: i-heroicons-question-mark-circle
---

::callout{type="tip" icon="i-heroicons-book-open"}
**Query Examples**: For complete `useCollectionQuery` patterns (basic, filtering, pagination, sorting, relations), see [Querying Data](/fundamentals/querying).
::

This page answers the most frequently asked questions about Nuxt Crouton. For detailed troubleshooting, see the [Troubleshooting Guide](/guides/troubleshooting).

## Generation & Setup

### Q: What fields are auto-generated and should NOT be in my schema?

**A:** Never define these fields in your schema files:

- `id` - Always auto-generated (UUID or nanoid)
- `teamId`, `userId` - Always auto-generated (team-scoped by default)
- `createdAt`, `updatedAt`, `updatedBy` - Generated when `useMetadata: true` (default)

Defining these manually causes duplicate key errors during build.

::alert{type="warning"}
**Common mistake:**
```json
{
  "id": { "type": "string" },         // ‚ùå Remove
  "createdAt": { "type": "date" },    // ‚ùå Remove
  "teamId": { "type": "string" },     // ‚ùå Remove
  "title": { "type": "string" }       // ‚úÖ Keep
}
```
::

See: [Schema Format - Auto-Generated Fields](/generation/schema-format#auto-generated-fields)

---

### Q: How do I regenerate a collection without losing customizations?

**A:** Nuxt Crouton generates code in layers, which you can freely customize. Regeneration is safe as long as you:

1. **Keep custom components separate** - Place them in subdirectories like `components/custom/`
2. **Use slots for overrides** - Override specific fields/columns via slots instead of editing generated files
3. **Commit before regenerating** - Always commit working code before running the generator

```bash
# Safe regeneration workflow
git add .
git commit -m "Before regeneration"
npx crouton-generate config crouton.config.js products --force
```

See: [Customization](/customization)

---

### Q: Should collection names be singular or plural?

**A:** Always use **plural** names:

```yaml
# ‚úÖ Correct
name: products
name: blogPosts
name: orderItems

# ‚ùå Wrong
name: product
name: blog_post
name: orderItem
```

See: [Conventions - Collection Names](/reference/conventions#collection-names)

---

### Q: What naming convention should I use for fields?

**A:** Use **camelCase** for all field names:

```json
{
  "firstName": { "type": "string" },      // ‚úÖ Correct
  "isActive": { "type": "boolean" },      // ‚úÖ Correct
  "publishedAt": { "type": "date" },      // ‚úÖ Correct

  "first_name": { "type": "string" },     // ‚ùå Wrong (snake_case)
  "FirstName": { "type": "string" }       // ‚ùå Wrong (PascalCase)
}
```

See: [Conventions - Field Names](/reference/conventions#field-names)

---

## Data Operations

### Q: Why isn't my data updating after save/delete?

**A:** This is usually a cache invalidation issue. Check:

1. **Collection name matches** between query and mutation
2. **Using `useCollectionMutation()`** which auto-invalidates cache

```typescript
// ‚úÖ Correct - auto-invalidation
const { create, update } = useCollectionMutation('products')
await create({ title: 'New Product' })

// ‚ùå Wrong - manual invalidation needed
const { mutate } = useCroutonMutate()
await mutate('create', 'products', data)
await refreshNuxtData((key) => key.startsWith('collection:products:'))
```

See: [Troubleshooting - Data Not Updating](/guides/troubleshooting#data-not-updating-after-save)

---

### Q: How do I handle loading and error states?

**A:** All query composables return `pending` and `error` properties. Use these to conditionally render loading spinners, error messages, and retry buttons. For the complete pattern, see [Best Practices - Handle Loading States](/guides/best-practices#handle-loading-and-error-states).

---

### Q: When should I use `useCollectionMutation()` vs `useCroutonMutate()`?

**A:**

**Use `useCollectionMutation()`** for:
- Generated forms
- Repeated operations on same collection
- Multi-step wizards
- Bulk operations

**Use `useCroutonMutate()`** for:
- Quick toggle buttons
- One-off actions
- Different collections in same component

::callout{type="tip" icon="i-heroicons-book-open"}
**Examples**: See [Mutation Composables API](/api-reference/composables/mutation-composables) for complete usage patterns.
::

See: [Best Practices - Choose the Right Mutation Method](/guides/best-practices#choose-the-right-mutation-method)

---

## Customization

### Q: How do I customize a single form field?

**A:** Use the `#field-[fieldName]` slot:

```vue
<script setup lang="ts">
const { formData, save } = useCollectionForm('products')
</script>

<template>
  <CroutonForm v-model="formData" @save="save">
    <!-- Override price field -->
    <template #field-price>
      <CustomPriceField v-model="formData.price" />
    </template>
  </CroutonForm>
</template>
```

See: [Customization - Custom Components](/customization/custom-components)

---

### Q: How do I customize a table column?

**A:** Use the `#column-[fieldName]` slot:

```vue
<template>
  <CroutonTable :data="products">
    <template #column-status="{ row }">
      <UBadge
        :color="row.status === 'active' ? 'green' : 'gray'"
      >
        {{ row.status }}
      </UBadge>
    </template>
  </CroutonTable>
</template>
```

See: [Customization - Custom Columns](/customization/custom-columns)

---

### Q: Can I completely replace a generated component?

**A:** Yes, create a component with the same name in your layer:

```
layers/products/components/
‚îî‚îÄ‚îÄ CroutonForm.vue  ‚Üê Your custom version
```

This overrides the generated component entirely.

See: [Customization Overview](/customization)

---

## TypeScript & Development

### Q: Why am I getting "Cannot find module" errors after generation?

**A:** TypeScript server needs to be restarted:

**In VS Code:**
1. Press `Cmd+Shift+P` (Mac) or `Ctrl+Shift+P` (Windows)
2. Type "Restart TS Server"
3. Select "TypeScript: Restart TS Server"

**Or clear cache:**
```bash
rm -rf .nuxt
npx nuxt prepare
```

See: [Troubleshooting - Type Errors](/guides/troubleshooting#type-errors-after-generation)

---

### Q: How do I get type safety for queries?

**A:** Use TypeScript generics with `useCollectionQuery<YourType>()` to get full type safety. Import your type from the layer's types file and pass it as a generic parameter. See: [Best Practices - Type Your Queries](/guides/best-practices#always-type-your-queries).

---

### Q: Why aren't Tailwind classes working in layer components?

**A:** Tailwind v4 doesn't auto-scan `node_modules`. Add `@source` directive:

```css
/* app/assets/css/tailwind.css */
@import "tailwindcss";
@import "@nuxt/ui";

/* Scan Nuxt Crouton layers */
@source "../../../node_modules/@fyit/crouton*/app/**/*.{vue,js,ts}";
```

Then restart dev server:
```bash
pnpm dev
```

See: [Troubleshooting - Tailwind Classes](/guides/troubleshooting#tailwind-classes-not-working)

---

## Relations & References

### Q: How do I define a relationship between collections?

**A:** Use `reference` field type with `ref-target`:

```yaml
# posts.yml
fields:
  - name: authorId
    type: reference
    ref-target: users      # Target collection (plural)

  - name: categoryIds
    type: reference
    ref-target: categories
    multiple: true         # Many-to-many
```

See: [Patterns - Relations](/patterns/relations)

---

### Q: How do I query related data?

**A:** Use the `include` option in your query to load related data. See [Querying with Relations](/fundamentals/querying#with-relations) for the complete pattern and [Patterns - Relations](/patterns/relations) for advanced usage.

---

## Forms & Validation

### Q: Why aren't validation errors showing?

**A:** Check that:

1. Schema is passed to form: `:schema="schema"`
2. Field names match schema keys
3. State is reactive (`ref()` or `reactive()`)

```vue
<script setup lang="ts">
import { z } from 'zod'

const schema = z.object({
  name: z.string().min(1, 'Required'),
  price: z.number().min(0)
})

const state = ref({ name: '', price: 0 })
</script>

<template>
  <UForm :state="state" :schema="schema" @submit="handleSubmit">
    <UFormField label="Name" name="name">
      <UInput v-model="state.name" />
    </UFormField>
  </UForm>
</template>
```

See: [Troubleshooting - Validation Errors](/guides/troubleshooting#validation-errors-not-showing)

---

### Q: How do I create conditional fields?

**A:** Use `v-if` with reactive state:

```vue
<script setup lang="ts">
const productType = ref('physical')
</script>

<template>
  <UFormField label="Type" name="type">
    <USelect v-model="productType" :options="['physical', 'digital']" />
  </UFormField>

  <!-- Only show for physical products -->
  <UFormField v-if="productType === 'physical'" label="Weight" name="weight">
    <UInput v-model="formData.weight" type="number" />
  </UFormField>
</template>
```

See: [Patterns - Forms](/patterns/forms)

---

## Performance

### Q: How do I optimize for large datasets?

**A:** Use these strategies:

1. **Implement pagination** - See [Querying with Pagination](/fundamentals/querying#with-pagination)
2. **Use server-side filtering** - Filter in your database, not the frontend
3. **Optimize relations** - Use server-side joins instead of multiple queries

See: [Troubleshooting - Performance Issues](/guides/troubleshooting#performance-issues)

---

## Features

### Q: Which features are production-ready?

**A:**

- **Stable** ‚úÖ - Production-ready (Internationalization)
- **Beta** üî¨ - Safe for non-critical use (Rich Text, Maps, Connectors, DevTools)
- **Experimental** ‚ö†Ô∏è - Use with caution (Assets, Events)

See: [Features Overview](/features)

---

### Q: How do I enable internationalization (i18n)?

**A:**

1. **Extend the i18n layer:**
```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  extends: [
    '@fyit/crouton',
    '@fyit/crouton-i18n'
  ]
})
```

2. **Mark fields as translatable:**
```javascript
// crouton.config.js
export default {
  translations: {
    collections: {
      products: ['name', 'description']
    }
  }
}
```

3. **Query with locale:**
Bind your query to the i18n locale reactively (see [Querying with Filters](/fundamentals/querying#with-filters-and-search) for the pattern).

See: [Internationalization](/features/internationalization)

---

## Deployment

### Q: Do I need to regenerate code before deploying?

**A:** No, generated code is committed to your repository. Just deploy as normal:

```bash
pnpm build
```

---

### Q: What environment variables do I need?

**A:** Depends on your setup:

**Database:**
- `DATABASE_URL` - Database connection string

**Team-based auth:**
- Session/auth provider variables (e.g., `NUXT_SESSION_SECRET`)

**Features:**
- i18n: `NUXT_PUBLIC_I18N_DEFAULT_LOCALE`
- Assets: Storage provider credentials (S3, R2, etc.)

Check your layer's documentation for specific requirements.

---

## Getting Help

### Q: Where can I get help if my question isn't answered here?

**A:**

1. **Check [Troubleshooting Guide](/guides/troubleshooting)** for detailed solutions
2. **Search [GitHub Issues](https://github.com/pmcp/nuxt-crouton/issues)** for similar problems
3. **Ask in [GitHub Discussions](https://github.com/pmcp/nuxt-crouton/discussions)** for general questions
4. **Create an issue** with:
   - Nuxt Crouton version
   - Nuxt version
   - Error messages
   - Minimal reproduction steps

---

## Related Resources

- [Troubleshooting Guide](/guides/troubleshooting) - Detailed problem-solving
- [Best Practices](/guides/best-practices) - Recommended patterns
- [Conventions](/reference/conventions) - Naming and organization standards
- [Glossary](/reference/glossary) - Term definitions
