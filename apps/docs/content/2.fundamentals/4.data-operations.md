---
title: Data Operations (Mutations)
description: Creating, updating, and deleting data in Nuxt Crouton
icon: i-heroicons-arrow-path
---

Nuxt Crouton provides two ways to mutate data:

## Quick Way: useCroutonMutate()

**Use when:** One-off actions, utilities, prototyping

```vue
<script setup lang="ts">
const { mutate } = useCroutonMutate()

// Create
await mutate('create', 'shopProducts', {
  name: 'New Product',
  price: 29.99
})

// Update
await mutate('update', 'shopProducts', {
  id: 'product-123',
  name: 'Updated Name'
})

// Delete
await mutate('delete', 'shopProducts', ['id1', 'id2'])
</script>
```

## Optimized Way: useCollectionMutation()

**Use when:** Forms, repeated operations

::callout{type="tip" icon="i-heroicons-book-open"}
**Complete Examples**: For full `useCollectionMutation` usage patterns and API details, see [Mutation Composables](/api-reference/composables/mutation-composables).
::

## When to Use Which?

::callout{type="info"}
For a detailed comparison and decision matrix, see the [Mutation Composables API Reference](/api-reference/composables/mutation-composables#comparison).
::

## Create Operations

### Basic Create

```vue
<script setup lang="ts">
const { create } = useCollectionMutation('shopProducts')

const handleCreate = async () => {
  const newProduct = await create({
    name: 'Widget',
    price: 19.99,
    inStock: true
  })

  console.log('Created:', newProduct.id)
}
</script>
```

### Create with Relations

```vue
<script setup lang="ts">
const { create } = useCollectionMutation('shopProducts')

// Create product with category relation
await create({
  name: 'Widget',
  price: 19.99,
  categoryId: 'cat-123'  // Foreign key
})
```

## Update Operations

### Basic Update

```vue
<script setup lang="ts">
const { update } = useCollectionMutation('shopProducts')

const handleUpdate = async (productId: string) => {
  await update(productId, {
    name: 'Updated Widget',
    price: 24.99
  })
  // updatedBy and updatedAt are automatically set
}
</script>
```

::callout{icon="i-heroicons-information-circle" color="blue"}
**Automatic Audit Tracking:** When you update a record, the system automatically sets:
- `updatedBy` to the current user's ID
- `updatedAt` to the current timestamp

You don't need to manually include these fields in your update data. The `userId` field (creator) remains unchanged.
::

### Partial Update

```vue
<script setup lang="ts">
// Only update specific fields
await update('product-123', {
  price: 29.99  // Only price changes
})
```

## Delete Operations

### Single Delete

```vue
<script setup lang="ts">
const { deleteItems } = useCollectionMutation('shopProducts')

const handleDelete = async (productId: string) => {
  await deleteItems([productId])
}
</script>
```

### Bulk Delete

```vue
<script setup lang="ts">
const { deleteItems } = useCollectionMutation('shopProducts')

const handleBulkDelete = async (productIds: string[]) => {
  await deleteItems(productIds)
}
</script>
```

## Bulk Operations

For bulk update, delete, and other batch operations on multiple records, see the dedicated [Bulk Operations](/advanced/bulk-operations) guide.

::callout{type="tip"}
**Quick tip**: Use a loop with `useCroutonMutate` for simple bulk operations, or implement optimistic updates for better UX.
::

## Error Handling

```vue
<script setup lang="ts">
const { create } = useCollectionMutation('shopProducts')

const handleCreate = async () => {
  try {
    await create({
      name: 'Widget',
      price: 19.99
    })
    // Success - cache automatically refreshes
  } catch (error) {
    console.error('Failed to create product:', error)
    // Show error toast
  }
}
</script>
```

## Optimistic Updates

For implementing optimistic updates with rollback on error, see the dedicated [Optimistic Updates](/advanced/optimistic-updates) guide.

::callout{type="tip"}
**Quick tip**: Optimistic updates improve perceived performance by updating the UI before the server responds.
::

## Cache Invalidation

Mutations automatically invalidate and refresh all related queries:

```typescript
// After mutation, all matching caches refresh automatically
await create({ name: 'New Product' })
// â†’ Triggers refetch for all shopProducts queries

// These all get refreshed:
// collection:shopProducts:{}
// collection:shopProducts:{"page":1}
// collection:shopProducts:{"page":2}
// collection:shopProducts:{"locale":"en"}
```

## See Also

::callout{type="info" icon="i-heroicons-book-open"}
**Related Documentation**:
- [Mutation Composables API Reference](/api-reference/composables/mutation-composables) - Complete API signatures and advanced patterns
- [Bulk Operations](/advanced/bulk-operations) - Batch operations on multiple records
- [Optimistic Updates](/advanced/optimistic-updates) - Improve UX with instant feedback
- [Migration Guide](/guides/migration) - Migrating from v1 mutation APIs
::

## Related Topics

- [Querying Data](/fundamentals/querying)
- [Caching](/fundamentals/caching)
- [Forms & Modals](/fundamentals/forms-modals)
